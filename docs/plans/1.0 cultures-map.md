# Cultures.com Interactive Map Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build a web service displaying nations on an interactive **globe map** with detailed cultural information (languages with phrases, and content including food, music, and other media) accessible via modal popups. Includes user authentication, nation submission system with polygon drawing, and admin moderation panel.

**Architecture:** Next.js 16+ App Router handles both frontend and API routes. MapLibre GL renders the interactive **globe-projected map** with OpenFreeMap Liberty tiles. PostGIS stores nation boundaries as `GEOMETRY(MultiPolygon, 4326)` with metadata. Media files stored in MinIO (S3-compatible object storage), with URLs in database. Google OAuth via NextAuth for authentication. **Dark/light theme support** with localStorage persistence.

**Tech Stack:** Next.js 16 (App Router), MapLibre GL (globe projection), OpenFreeMap Liberty, **Mantine + TailwindCSS + shadcn-style theme**, PostGIS 17-3.5, MinIO, Docker, TypeScript, Prisma ORM, NextAuth, **Zustand (state management)**

**UI Layout:**
- Full-screen globe map as main view
- Right sidebar controls (zoom, theme toggle, user profile, info) - based on whopins MainPageControls
- Bottom center "+" button for adding new nations via polygon drawing
- Modal popups for nation details

---

## Phase 1: Project Foundation

### Task 1: Initialize Next.js Project

**Files:**

- Create: `package.json`
- Create: `tsconfig.json`
- Create: `next.config.ts`
- Create: `tailwind.config.ts`
- Create: `.gitignore`

**Step 1: Create Next.js project**

Run:

```bash
npx create-next-app@latest . --typescript --tailwind --eslint --app --src-dir --import-alias "@/*"
```

Expected: Project scaffolded with App Router structure

**Step 2: Verify project runs**

Run:

```bash
npm run dev
```

Expected: Dev server starts on http://localhost:3000

**Step 3: Commit**

```bash
git init
git add .
git commit -m "chore: initialize Next.js 16 project with TypeScript and Tailwind"
```

---

### Task 2: Install Core Dependencies

**Files:**

- Modify: `package.json`

**Step 1: Install MapLibre GL**

Run:

```bash
npm install maplibre-gl
npm install -D @types/maplibre-gl
```

**Step 2: Install Prisma for database**

Run:

```bash
npm install prisma @prisma/client
npm install -D prisma
```

**Step 3: Install Mantine UI**

Run:

```bash
npm install @mantine/core @mantine/hooks @mantine/form @mantine/notifications @mantine/modals
npm install @tabler/icons-react
```

**Step 4: Install PostCSS dependencies for Mantine**

Run:

```bash
npm install postcss postcss-preset-mantine postcss-simple-vars
```

**Step 5: Create PostCSS config**

Create `postcss.config.mjs`:

```javascript
// postcss.config.mjs
const config = {
  plugins: {
    "postcss-preset-mantine": {},
    "postcss-simple-vars": {
      variables: {
        "mantine-breakpoint-xs": "36em",
        "mantine-breakpoint-sm": "48em",
        "mantine-breakpoint-md": "62em",
        "mantine-breakpoint-lg": "75em",
        "mantine-breakpoint-xl": "88em",
      },
    },
    tailwindcss: {},
    autoprefixer: {},
  },
};

export default config;
```

**Step 6: Install additional utilities**

Run:

```bash
npm install lucide-react zod react-hook-form @hookform/resolvers
npm install -D @types/node
```

**Step 7: Commit**

```bash
git add .
git commit -m "chore: install maplibre-gl, prisma, mantine, and utilities"
```

---

### Task 3: Configure Mantine Provider with Theme System

**Files:**

- Modify: `src/app/layout.tsx`
- Create: `src/components/providers/mantine-provider.tsx`
- Create: `src/theme/index.ts`
- Create: `src/theme/theme.ts`
- Create: `src/theme/cssVariableResolver.ts`
- Create: `src/theme/localStorageColorSchemeManager.ts`
- Create: `src/theme/style.css`

**Step 1: Create theme configuration (based on whopins/shadcn theme)**

```typescript
// src/theme/theme.ts
import {
  ActionIcon,
  Alert,
  Anchor,
  Avatar,
  Badge,
  Blockquote,
  Button,
  Card,
  Checkbox,
  Chip,
  Container,
  createTheme,
  Dialog,
  Indicator,
  Mark,
  NavLink,
  Pagination,
  Paper,
  Radio,
  rem,
  SegmentedControl,
  Select,
  Stepper,
  Switch,
  ThemeIcon,
  Timeline,
  Tooltip,
} from "@mantine/core";

const CONTAINER_SIZES: Record<string, string> = {
  xxs: rem("200px"),
  xs: rem("300px"),
  sm: rem("400px"),
  md: rem("500px"),
  lg: rem("600px"),
  xl: rem("1400px"),
  xxl: rem("1600px"),
};

const slateColors: [string, ...string[]] = [
  "#f8fafc",
  "#f1f5f9",
  "#e2e8f0",
  "#cbd5e1",
  "#94a3b8",
  "#475569",
  "#334155",
  "#1e293b",
  "#0f172a",
  "#020817",
];

const blueColors: [string, ...string[]] = [
  "#eff6ff",
  "#dbeafe",
  "#bfdbfe",
  "#93c5fd",
  "#60a5fa",
  "#3b82f6",
  "#2563eb",
  "#1e40af",
  "#1e3a8a",
  "#172554",
];

const greenColors: [string, ...string[]] = [
  "#F0FDF4",
  "#DCFCE7",
  "#BBF7D0",
  "#86EFAC",
  "#4ADE80",
  "#22c55e",
  "#16A34A",
  "#166534",
  "#14532D",
  "#052E16",
];

const redColors: [string, ...string[]] = [
  "#FEF2F2",
  "#FEE2E2",
  "#FECACA",
  "#FCA5A5",
  "#F87171",
  "#DC2626",
  "#B91C1C",
  "#991B1B",
  "#7F1D1D",
  "#450A0A",
];

const amberColors: [string, ...string[]] = [
  "#FFFBEB",
  "#FEF3C7",
  "#FDE68A",
  "#FCD34D",
  "#FBBF24",
  "#f59e0b",
  "#D97706",
  "#92400E",
  "#78350F",
  "#451A03",
];

export const shadcnTheme = createTheme({
  colors: {
    slate: slateColors,
    blue: blueColors,
    green: greenColors,
    red: redColors,
    amber: amberColors,
    primary: slateColors,
    secondary: slateColors,
    dark: slateColors,
    error: redColors,
    success: greenColors,
    info: blueColors,
    warning: amberColors,
  },
  focusRing: "never",
  scale: 1,
  primaryColor: "primary",
  primaryShade: { light: 8, dark: 0 },
  autoContrast: true,
  luminanceThreshold: 0.3,
  fontFamily: "Geist, system-ui, sans-serif",
  radius: {
    xs: rem("6px"),
    sm: rem("8px"),
    md: rem("12px"),
    lg: rem("16px"),
    xl: rem("24px"),
  },
  defaultRadius: "sm",
  cursorType: "pointer",
  components: {
    Container: Container.extend({
      vars: (_, { size, fluid }) => ({
        root: {
          "--container-size": fluid
            ? "100%"
            : size !== undefined && size in CONTAINER_SIZES
            ? CONTAINER_SIZES[size]
            : rem(size as number),
        },
      }),
    }),
    Paper: Paper.extend({
      defaultProps: {
        shadow: "xl",
      },
    }),
    Card: Card.extend({
      defaultProps: {
        p: "xl",
        shadow: "xl",
        withBorder: true,
      },
    }),
    Dialog: Dialog.extend({
      defaultProps: {
        withBorder: true,
      },
    }),
  },
});
```

**Step 2: Create CSS variable resolver for light/dark themes**

```typescript
// src/theme/cssVariableResolver.ts
import { alpha, CSSVariablesResolver } from "@mantine/core";

export const shadcnCssVariableResolver: CSSVariablesResolver = () => ({
  variables: {
    "--mantine-heading-font-weight": "600",
    "--mantine-primary-color-filled-hover": alpha(
      "var(--mantine-primary-color-filled)",
      0.9
    ),
    "--mantine-primary-color-light": "var(--mantine-color-slate-light)",
    "--mantine-primary-color-light-hover": "var(--mantine-color-slate-light-hover)",
    "--mantine-primary-color-light-color": "var(--mantine-color-slate-light-color)",
  },
  light: {
    "--mantine-primary-color-contrast": "var(--mantine-color-slate-0)",
    "--mantine-color-text": "var(--mantine-color-secondary-9)",
    "--mantine-color-body": "var(--mantine-color-white)",
    "--mantine-color-error": "var(--mantine-color-error-10)",
    "--mantine-color-placeholder": "var(--mantine-color-secondary-10)",
    "--mantine-color-anchor": "var(--mantine-color-secondary-10)",
    "--mantine-color-default": "var(--mantine-color-secondary-0)",
    "--mantine-color-default-hover": "var(--mantine-color-secondary-1)",
    "--mantine-color-default-color": "var(--mantine-color-secondary-9)",
    "--mantine-color-default-border": "var(--mantine-color-secondary-2)",
    "--mantine-color-dimmed": "var(--mantine-color-secondary-10)",
    "--mantine-color-secondary-filled": "var(--mantine-color-white)",
    "--mantine-color-secondary-filled-hover": "var(--mantine-color-secondary-1)",
    "--mantine-color-secondary-light": "var(--mantine-color-secondary-1)",
    "--mantine-color-secondary-light-hover": alpha(
      "var(--mantine-color-secondary-light)",
      0.8
    ),
    "--mantine-color-secondary-outline": "var(--mantine-color-secondary-9)",
    "--mantine-color-secondary-outline-hover": alpha(
      "var(--mantine-color-secondary-outline)",
      0.05
    ),
  },
  dark: {
    "--mantine-primary-color-contrast": "var(--mantine-color-slate-9)",
    "--mantine-color-text": "var(--mantine-color-secondary-0)",
    "--mantine-color-body": "var(--mantine-color-secondary-9)",
    "--mantine-color-error": "var(--mantine-color-error-10)",
    "--mantine-color-placeholder": "var(--mantine-color-secondary-4)",
    "--mantine-color-anchor": "var(--mantine-color-secondary-4)",
    "--mantine-color-default": "var(--mantine-color-secondary-9)",
    "--mantine-color-default-hover": "var(--mantine-color-secondary-7)",
    "--mantine-color-default-color": "var(--mantine-color-secondary-1)",
    "--mantine-color-default-border": "var(--mantine-color-secondary-7)",
    "--mantine-color-dimmed": "var(--mantine-color-secondary-4)",
    "--mantine-color-secondary-filled": "var(--mantine-color-secondary-8)",
    "--mantine-color-secondary-filled-hover": "var(--mantine-color-secondary-7)",
    "--mantine-color-secondary-light": "var(--mantine-color-secondary-7)",
    "--mantine-color-secondary-light-hover": alpha(
      "var(--mantine-color-secondary-light)",
      0.8
    ),
    "--mantine-color-secondary-outline": "var(--mantine-color-secondary-0)",
    "--mantine-color-secondary-outline-hover": alpha(
      "var(--mantine-color-secondary-outline)",
      0.05
    ),
  },
});
```

**Step 3: Create localStorage color scheme manager**

```typescript
// src/theme/localStorageColorSchemeManager.ts
import { isMantineColorScheme, MantineColorSchemeManager } from "@mantine/core";

const key = "cultures-color-scheme";

export function localStorageColorSchemeManager(): MantineColorSchemeManager {
  let handleStorageEvent: ((event: StorageEvent) => void) | undefined;

  return {
    get: (defaultValue) => {
      if (typeof window === "undefined") {
        return defaultValue;
      }

      try {
        const value = window.localStorage.getItem(key);
        return value && isMantineColorScheme(value) ? value : defaultValue;
      } catch {
        return defaultValue;
      }
    },

    set: (value) => {
      try {
        window.localStorage.setItem(key, value);
      } catch (error) {
        console.warn(
          "[@mantine/core] Local storage color scheme manager was unable to save color scheme.",
          error
        );
      }
    },

    subscribe: (onUpdate) => {
      handleStorageEvent = (event) => {
        if (event.storageArea === window.localStorage && event.key === key) {
          if (isMantineColorScheme(event.newValue)) {
            onUpdate(event.newValue);
          }
        }
      };

      window.addEventListener("storage", handleStorageEvent);
    },

    unsubscribe: () => {
      if (handleStorageEvent) {
        window.removeEventListener("storage", handleStorageEvent);
      }
    },

    clear: () => {
      window.localStorage.removeItem(key);
    },
  };
}
```

**Step 4: Create theme styles CSS**

```css
/* src/theme/style.css */
@tailwind components;
@tailwind utilities;

/* Main page controls variant for ActionIcon and Button */
.mantine-ActionIcon-root,
.mantine-Button-root {
  &[data-variant="main-page-control"] {
    @mixin dark {
      --ai-bd: calc(0.0625rem * var(--mantine-scale)) solid
        var(--mantine-color-secondary-7);
      --ai-hover: var(--mantine-color-secondary-7);
      --ai-bg: var(--mantine-color-secondary-9);
      --ai-color: var(--mantine-color-secondary-1);
    }

    @mixin light {
      --ai-bd: calc(0.0625rem * var(--mantine-scale)) solid
        var(--mantine-color-secondary-3);
      --ai-hover: var(--mantine-color-secondary-2);
      --ai-bg: var(--mantine-color-secondary-1);
      --ai-color: var(--mantine-color-secondary-9);
    }

    background: var(--ai-bg, var(--mantine-primary-color-filled));
    color: var(--ai-color);
    border: var(--ai-bd, calc(0.0625rem * var(--mantine-scale)) solid transparent);

    &:hover,
    &:active {
      background-color: var(--ai-hover, var(--mantine-primary-color-filled-hover));
      color: var(--ai-hover-color, var(--ai-color));
    }
  }
}

/* Theme toggle icons */
.dark {
  @mixin dark {
    display: none;
  }

  @mixin light {
    display: block;
  }
}

.light {
  @mixin light {
    display: none;
  }

  @mixin dark {
    display: block;
  }
}
```

**Step 5: Create theme index export**

```typescript
// src/theme/index.ts
export { shadcnTheme } from "./theme";
export { shadcnCssVariableResolver } from "./cssVariableResolver";
export { localStorageColorSchemeManager } from "./localStorageColorSchemeManager";
```

**Step 6: Create Mantine provider wrapper with theme support**

```typescript
// src/components/providers/mantine-provider.tsx
"use client";

import { MantineProvider } from "@mantine/core";
import { Notifications } from "@mantine/notifications";
import { ModalsProvider } from "@mantine/modals";
import "@mantine/core/styles.css";
import "@mantine/notifications/styles.css";
import "@/theme/style.css";
import {
  shadcnTheme,
  shadcnCssVariableResolver,
  localStorageColorSchemeManager,
} from "@/theme";

export function MantineProviderWrapper({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <MantineProvider
      theme={shadcnTheme}
      cssVariablesResolver={shadcnCssVariableResolver}
      colorSchemeManager={localStorageColorSchemeManager()}
      defaultColorScheme="auto"
    >
      <Notifications position="top-right" />
      <ModalsProvider>{children}</ModalsProvider>
    </MantineProvider>
  );
}
```

**Step 7: Update root layout**

```typescript
// src/app/layout.tsx
import type { Metadata } from "next";
import { Geist } from "next/font/google";
import "./globals.css";
import { MantineProviderWrapper } from "@/components/providers/mantine-provider";
import { ColorSchemeScript } from "@mantine/core";

const geist = Geist({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "Cultures.com - Explore World Cultures",
  description: "Interactive map exploring nations and their cultures",
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en" suppressHydrationWarning>
      <head>
        <ColorSchemeScript defaultColorScheme="auto" />
      </head>
      <body className={geist.className}>
        <MantineProviderWrapper>{children}</MantineProviderWrapper>
      </body>
    </html>
  );
}
```

**Step 8: Commit**

```bash
git add .
git commit -m "feat: configure Mantine provider with shadcn theme and dark/light mode support"
```

---

### Task 4: Docker Development Setup

**Files:**

- Create: `docker-compose.yml`
- Create: `docker-compose.prod.yml`
- Create: `.env.example`
- Create: `.env.local`
- Modify: `.gitignore`

**Step 1: Create development docker-compose.yml**

```yaml
# docker-compose.yml
version: "3.8"

services:
  db:
    image: ghcr.io/baosystems/postgis:17-3.5
    container_name: cultures_db
    environment:
      POSTGRES_USER: cultures
      POSTGRES_PASSWORD: cultures_dev_password
      POSTGRES_DB: cultures
    ports:
      - "5432:5432"
    volumes:
      - ./data/postgres:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U cultures -d cultures"]
      interval: 5s
      timeout: 5s
      retries: 5

  minio:
    image: minio/minio:latest
    container_name: cultures_minio
    environment:
      MINIO_ROOT_USER: cultures
      MINIO_ROOT_PASSWORD: cultures_dev_password
    ports:
      - "9000:9000"
      - "9001:9001"
    volumes:
      - ./data/minio:/data
    command: server /data --console-address ":9001"
    healthcheck:
      test: ["CMD", "mc", "ready", "local"]
      interval: 5s
      timeout: 5s
      retries: 5
```

**Step 2: Create production docker-compose.prod.yml**

```yaml
# docker-compose.prod.yml
version: "3.8"

services:
  app:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: cultures_app
    environment:
      - DATABASE_URL=postgresql://cultures:${POSTGRES_PASSWORD}@db:5432/cultures
      - NEXT_PUBLIC_MAP_STYLE=https://tiles.openfreemap.org/styles/liberty
      - MINIO_ENDPOINT=minio:9000
      - MINIO_ACCESS_KEY=${MINIO_ACCESS_KEY}
      - MINIO_SECRET_KEY=${MINIO_SECRET_KEY}
      - MINIO_BUCKET=cultures
      - GOOGLE_CLIENT_ID=${GOOGLE_CLIENT_ID}
      - GOOGLE_CLIENT_SECRET=${GOOGLE_CLIENT_SECRET}
      - NEXTAUTH_SECRET=${NEXTAUTH_SECRET}
      - NEXTAUTH_URL=${NEXTAUTH_URL}
    ports:
      - "3000:3000"
    depends_on:
      db:
        condition: service_healthy
      minio:
        condition: service_healthy
    restart: unless-stopped

  db:
    image: ghcr.io/baosystems/postgis:17-3.5
    container_name: cultures_db_prod
    environment:
      POSTGRES_USER: cultures
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: cultures
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U cultures -d cultures"]
      interval: 5s
      timeout: 5s
      retries: 5
    restart: unless-stopped

  minio:
    image: minio/minio:latest
    container_name: cultures_minio_prod
    environment:
      MINIO_ROOT_USER: ${MINIO_ACCESS_KEY}
      MINIO_ROOT_PASSWORD: ${MINIO_SECRET_KEY}
    ports:
      - "9000:9000"
      - "9001:9001"
    volumes:
      - minio_data:/data
    command: server /data --console-address ":9001"
    healthcheck:
      test: ["CMD", "mc", "ready", "local"]
      interval: 5s
      timeout: 5s
      retries: 5
    restart: unless-stopped

volumes:
  postgres_data:
  minio_data:
```

**Step 3: Create .env.example**

```env
# Database
DATABASE_URL="postgresql://cultures:cultures_dev_password@localhost:5432/cultures"

# Map
NEXT_PUBLIC_MAP_STYLE="https://tiles.openfreemap.org/styles/liberty"

# MinIO (S3-compatible storage)
MINIO_ENDPOINT="localhost:9000"
MINIO_ACCESS_KEY="cultures"
MINIO_SECRET_KEY="cultures_dev_password"
MINIO_BUCKET="cultures"
MINIO_USE_SSL="false"

# MinIO public URL (for frontend)
NEXT_PUBLIC_MINIO_ENDPOINT="localhost:9000"
NEXT_PUBLIC_MINIO_BUCKET="cultures"
NEXT_PUBLIC_MINIO_USE_SSL="false"

# Google OAuth
GOOGLE_CLIENT_ID="your-google-client-id"
GOOGLE_CLIENT_SECRET="your-google-client-secret"

# NextAuth
NEXTAUTH_SECRET="your-nextauth-secret-generate-with-openssl-rand-base64-32"
NEXTAUTH_URL="http://localhost:3000"

# Media uploads
MAX_FILE_SIZE_MB=50
```

**Step 4: Create .env.local (copy from example)**

```bash
cp .env.example .env.local
```

**Step 5: Update .gitignore**

Add to `.gitignore`:

```
# Environment
.env.local
.env.production

# Local data (synced with Docker volumes)
data/

# Database
postgres_data/
```

**Step 6: Create data directories**

Run:

```bash
mkdir -p data/postgres data/minio
```

**Step 7: Commit**

```bash
git add .
git commit -m "chore: add Docker setup for development and production"
```

---

### Task 5: Create Production Dockerfile

**Files:**

- Create: `Dockerfile`
- Create: `.dockerignore`

**Step 1: Create Dockerfile**

```dockerfile
# Dockerfile
FROM node:20-alpine AS base

# Install dependencies only when needed
FROM base AS deps
RUN apk add --no-cache libc6-compat
WORKDIR /app

COPY package.json package-lock.json* ./
RUN npm ci

# Rebuild the source code only when needed
FROM base AS builder
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY . .

RUN npx prisma generate
RUN npm run build

# Production image, copy all the files and run next
FROM base AS runner
WORKDIR /app

ENV NODE_ENV=production

RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nextjs

COPY --from=builder /app/public ./public
COPY --from=builder /app/.next/standalone ./
COPY --from=builder /app/.next/static ./.next/static
COPY --from=builder /app/prisma ./prisma

USER nextjs

EXPOSE 3000

ENV PORT=3000
ENV HOSTNAME="0.0.0.0"

CMD ["node", "server.js"]
```

**Step 2: Create .dockerignore**

```
.git
.gitignore
.next
node_modules
npm-debug.log
README.md
.env*
docker-compose*.yml
Dockerfile
.dockerignore
postgres_data
public/uploads
```

**Step 3: Update next.config.ts for standalone output**

```typescript
// next.config.ts
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  output: "standalone",
  images: {
    remotePatterns: [
      {
        protocol: "https",
        hostname: "**",
      },
    ],
  },
};

export default nextConfig;
```

**Step 4: Commit**

```bash
git add .
git commit -m "chore: add production Dockerfile with standalone output"
```

---

## Phase 2: Database Schema & Authentication

### Task 6: Initialize Prisma with PostGIS

**Files:**

- Create: `prisma/schema.prisma`

**Step 1: Initialize Prisma**

Run:

```bash
npx prisma init
```

**Step 2: Configure schema.prisma with PostGIS and User/Nation models**

```prisma
// prisma/schema.prisma
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  extensions = [postgis]
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  firstName String
  lastName  String
  isAdmin   Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  submittedNations Nation[]

  @@index([email])
}

enum NationState {
  approved
  pending
}

model Nation {
  id          String      @id @default(cuid())
  name        String      @unique
  slug        String      @unique
  state       NationState @default(pending)
  description String?
  flagUrl     String? // user uploaded flag image URL (uploaded on frontend and saved in minio via backend)

  // GeoJSON boundary - stored as native PostGIS geometry
  // Note: Prisma doesn't support PostGIS directly, we use raw SQL for geometry operations
  // This field stores the GeoJSON text for Prisma, but actual geometry is in boundary column
  boundaryGeoJson String? @db.Text

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  submittedById String?
  submittedBy   User? @relation(fields: [submittedById], references: [id])

  // Relations
  languages Language[]
  contents  Content[]

  @@index([slug])
  @@index([state])
}

model Language {
  id          String @id @default(cuid())
  name        String
  description String

  nationId String
  nation   Nation @relation(fields: [nationId], references: [id], onDelete: Cascade)

  phrases Phrase[]
}

model Phrase {
  id               String @id @default(cuid())
  languageId       String
  text             String // original phrase text
  translation      String // translated phrase text
  audioUrl         String // URL to audio file for pronunciation (recorded on frontend and saved in minio via backend)

  language Language @relation(fields: [languageId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
}

enum ContentType {
  IMAGE_UPLOAD
  VIDEO_UPLOAD
  VIDEO_YOUTUBE
}

enum ContentCategory {
  FOOD
  MUSIC
  OTHER
}

model Content {
  id           String       @id @default(cuid())
  title        String
  contentType  ContentType
  contentUrl   String?      // URL to image/video if applicable
  category     ContentCategory @default(OTHER)

  nationId String
  nation   Nation @relation(fields: [nationId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
}
```

**Step 3: Start database container**

Run:

```bash
docker-compose up -d db
```

Expected: PostGIS container starts and passes health check

**Step 4: Run initial migration**

Run:

```bash
npx prisma migrate dev --name init
```

Expected: Migration creates all tables with PostGIS extension enabled

**Step 5: Add PostGIS geometry column via raw SQL migration**

Create migration file `prisma/migrations/add_postgis_geometry/migration.sql`:

```sql
-- Add native PostGIS geometry column for spatial queries
ALTER TABLE "Nation" ADD COLUMN IF NOT EXISTS "boundary" geometry(MultiPolygon, 4326);

-- Create spatial index for efficient queries
CREATE INDEX IF NOT EXISTS "Nation_boundary_idx" ON "Nation" USING GIST ("boundary");

-- Function to update boundary geometry when boundaryGeoJson changes
CREATE OR REPLACE FUNCTION update_nation_boundary()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW."boundaryGeoJson" IS NOT NULL THEN
    NEW."boundary" = ST_SetSRID(ST_GeomFromGeoJSON(
      (NEW."boundaryGeoJson"::json->'geometry')::text
    ), 4326);
  ELSE
    NEW."boundary" = NULL;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to auto-update geometry
DROP TRIGGER IF EXISTS nation_boundary_update ON "Nation";
CREATE TRIGGER nation_boundary_update
  BEFORE INSERT OR UPDATE OF "boundaryGeoJson"
  ON "Nation"
  FOR EACH ROW
  EXECUTE FUNCTION update_nation_boundary();
```

Run the migration:

```bash
npx prisma migrate dev --name add_postgis_geometry
```

**Step 6: Generate Prisma client**

Run:

```bash
npx prisma generate
```

**Step 7: Commit**

```bash
git add .
git commit -m "feat: add Prisma schema with PostGIS geometry for nations and user model"
```

---

### Task 7: Setup NextAuth with Google OAuth

**Files:**

- Create: `src/app/api/auth/[...nextauth]/route.ts`
- Create: `src/lib/auth.ts`
- Create: `src/components/auth/auth-button.tsx`

**Step 1: Install NextAuth**

Run:

```bash
npm install next-auth @auth/prisma-adapter
```

**Step 2: Create auth configuration**

```typescript
// src/lib/auth.ts
import { NextAuthOptions } from "next-auth";
import GoogleProvider from "next-auth/providers/google";
import { PrismaAdapter } from "@auth/prisma-adapter";
import { db } from "@/lib/db";

export const authOptions: NextAuthOptions = {
  adapter: PrismaAdapter(db) as any,
  providers: [
    GoogleProvider({
      clientId: process.env.GOOGLE_CLIENT_ID!,
      clientSecret: process.env.GOOGLE_CLIENT_SECRET!,
      profile(profile) {
        return {
          id: profile.sub,
          email: profile.email,
          firstName: profile.given_name || profile.name?.split(" ")[0] || "",
          lastName:
            profile.family_name ||
            profile.name?.split(" ").slice(1).join(" ") ||
            "",
          isAdmin: false,
        };
      },
    }),
  ],
  callbacks: {
    async session({ session, user }) {
      if (session.user) {
        session.user.id = user.id;
        // Fetch isAdmin from database
        const dbUser = await db.user.findUnique({
          where: { id: user.id },
          select: { isAdmin: true },
        });
        session.user.isAdmin = dbUser?.isAdmin ?? false;
      }
      return session;
    },
  },
  pages: {
    signIn: "/auth/signin",
  },
};
```

**Step 3: Create auth API route**

```typescript
// src/app/api/auth/[...nextauth]/route.ts
import NextAuth from "next-auth";
import { authOptions } from "@/lib/auth";

const handler = NextAuth(authOptions);
export { handler as GET, handler as POST };
```

**Step 4: Add NextAuth type extensions**

Create `src/types/next-auth.d.ts`:

```typescript
// src/types/next-auth.d.ts
import "next-auth";

declare module "next-auth" {
  interface Session {
    user: {
      id: string;
      email: string;
      name?: string;
      image?: string;
      isAdmin: boolean;
    };
  }

  interface User {
    id: string;
    email: string;
    firstName: string;
    lastName: string;
    isAdmin: boolean;
  }
}
```

**Step 5: Create auth button component**

```typescript
// src/components/auth/auth-button.tsx
"use client";

import { Button, Menu, Avatar, Text } from "@mantine/core";
import { IconLogin, IconLogout, IconUser, IconShield } from "@tabler/icons-react";
import { useSession, signIn, signOut } from "next-auth/react";
import Link from "next/link";

export function AuthButton() {
  const { data: session, status } = useSession();

  if (status === "loading") {
    return <Button loading variant="subtle" />;
  }

  if (!session) {
    return (
      <Button
        leftSection={<IconLogin size={16} />}
        variant="light"
        onClick={() => signIn("google")}
      >
        Sign in with Google
      </Button>
    );
  }

  return (
    <Menu shadow="md" width={200}>
      <Menu.Target>
        <Button variant="subtle" className="px-2">
          <Avatar
            src={session.user.image}
            alt={session.user.name || "User"}
            radius="xl"
            size="sm"
          />
          <Text ml="xs" size="sm" className="hidden sm:inline">
            {session.user.name}
          </Text>
        </Button>
      </Menu.Target>

      <Menu.Dropdown>
        <Menu.Label>Account</Menu.Label>
        <Menu.Item leftSection={<IconUser size={14} />}>
          Profile
        </Menu.Item>
        {session.user.isAdmin && (
          <Menu.Item
            leftSection={<IconShield size={14} />}
            component={Link}
            href="/admin"
          >
            Admin Panel
          </Menu.Item>
        )}
        <Menu.Divider />
        <Menu.Item
          color="red"
          leftSection={<IconLogout size={14} />}
          onClick={() => signOut()}
        >
          Sign out
        </Menu.Item>
      </Menu.Dropdown>
    </Menu>
  );
}
```

**Step 6: Create SessionProvider wrapper**

```typescript
// src/components/providers/session-provider.tsx
"use client";

import { SessionProvider as NextAuthSessionProvider } from "next-auth/react";

export function SessionProvider({ children }: { children: React.ReactNode }) {
  return <NextAuthSessionProvider>{children}</NextAuthSessionProvider>;
}
```

**Step 7: Update root layout to include SessionProvider**

Update `src/app/layout.tsx` to wrap with SessionProvider:

```typescript
// src/app/layout.tsx
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";
import { MantineProviderWrapper } from "@/components/providers/mantine-provider";
import { SessionProvider } from "@/components/providers/session-provider";

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "Cultures.com - Explore World Cultures",
  description: "Interactive map exploring nations and their cultures",
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body className={inter.className}>
        <SessionProvider>
          <MantineProviderWrapper>{children}</MantineProviderWrapper>
        </SessionProvider>
      </body>
    </html>
  );
}
```

**Step 8: Commit**

```bash
git add .
git commit -m "feat: add NextAuth with Google OAuth and session management"
```

---

### Task 8: Create Database Client Singleton

**Files:**

- Create: `src/lib/db.ts`

**Step 1: Create Prisma client singleton**

```typescript
// src/lib/db.ts
import { PrismaClient } from "@prisma/client";

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined;
};

export const db =
  globalForPrisma.prisma ??
  new PrismaClient({
    log:
      process.env.NODE_ENV === "development"
        ? ["query", "error", "warn"]
        : ["error"],
  });

if (process.env.NODE_ENV !== "production") globalForPrisma.prisma = db;
```

**Step 2: Commit**

```bash
git add .
git commit -m "feat: add Prisma client singleton"
```

---

### Task 9: Seed Database with Sample Data

**Files:**

- Create: `prisma/seed.ts`
- Modify: `package.json`

**Step 1: Create seed file**

```typescript
// prisma/seed.ts
import { PrismaClient, ContentType, ContentCategory, NationState } from "@prisma/client";

const prisma = new PrismaClient();

async function main() {
  // Clear existing data
  await prisma.phrase.deleteMany();
  await prisma.language.deleteMany();
  await prisma.content.deleteMany();
  await prisma.nation.deleteMany();
  await prisma.user.deleteMany();

  // Create admin user
  const adminUser = await prisma.user.create({
    data: {
      email: "admin@cultures.com",
      firstName: "Admin",
      lastName: "User",
      isAdmin: true,
    },
  });

  // Create Japan (approved)
  const japan = await prisma.nation.create({
    data: {
      name: "Japan",
      slug: "japan",
      state: NationState.approved,
      description:
        "An island country in East Asia, known for its unique blend of ancient traditions and cutting-edge technology.",
      flagUrl: "flags/japan.svg",
      boundaryGeoJson: JSON.stringify({
        type: "Feature",
        properties: { name: "Japan" },
        geometry: {
          type: "MultiPolygon",
          coordinates: [
            [
              [
                [129.408463, 31.029579],
                [131.220475, 31.418238],
                [131.778344, 33.107691],
                [135.792984, 33.464923],
                [136.527402, 35.772532],
                [140.253279, 35.658073],
                [141.224969, 40.232738],
                [141.406618, 41.588834],
                [140.113556, 45.138722],
                [136.789418, 41.500206],
                [129.408463, 31.029579],
              ],
            ],
          ],
        },
      }),
      languages: {
        create: {
          name: "Japanese",
          description:
            "Japanese is an East Asian language spoken by about 128 million people, primarily in Japan. It uses three writing systems: Hiragana, Katakana, and Kanji.",
          phrases: {
            create: [
              {
                text: "こんにちは",
                translation: "Hello",
                audioUrl: "audio/japan/hello.mp3",
              },
              {
                text: "ありがとうございます",
                translation: "Thank you",
                audioUrl: "audio/japan/thankyou.mp3",
              },
              {
                text: "さようなら",
                translation: "Goodbye",
                audioUrl: "audio/japan/goodbye.mp3",
              },
            ],
          },
        },
      },
      contents: {
        create: [
          {
            title: "Sushi",
            contentType: ContentType.IMAGE_UPLOAD,
            contentUrl: "content/japan/sushi.jpg",
            category: ContentCategory.FOOD,
          },
          {
            title: "Ramen",
            contentType: ContentType.IMAGE_UPLOAD,
            contentUrl: "content/japan/ramen.jpg",
            category: ContentCategory.FOOD,
          },
          {
            title: "Traditional Tea Ceremony",
            contentType: ContentType.VIDEO_YOUTUBE,
            contentUrl: "https://www.youtube.com/watch?v=dQw4w9WgXcQ",
            category: ContentCategory.OTHER,
          },
        ],
      },
    },
  });

  // Create Brazil (approved)
  const brazil = await prisma.nation.create({
    data: {
      name: "Brazil",
      slug: "brazil",
      state: NationState.approved,
      description:
        "The largest country in South America, known for its Amazon rainforest and football.",
      flagUrl: "flags/brazil.svg",
      boundaryGeoJson: JSON.stringify({
        type: "Feature",
        properties: { name: "Brazil" },
        geometry: {
          type: "MultiPolygon",
          coordinates: [
            [
              [
                [-57.625133, -30.216295],
                [-53.373662, -33.768378],
                [-48.549541, -28.674115],
                [-40.696295, -22.356722],
                [-34.846291, -7.398605],
                [-43.413594, 2.153],
                [-51.657797, 4.156232],
                [-60.733574, 5.200277],
                [-69.52968, -0.549992],
                [-73.219711, -6.644789],
                [-72.352891, -13.535079],
                [-67.649685, -22.890352],
                [-57.625133, -30.216295],
              ],
            ],
          ],
        },
      }),
      languages: {
        create: {
          name: "Portuguese",
          description:
            "Brazilian Portuguese spoken by most of the 214 million inhabitants.",
          phrases: {
            create: [
              { text: "Olá", translation: "Hello", audioUrl: "audio/brazil/hello.mp3" },
              { text: "Obrigado/Obrigada", translation: "Thank you (male/female)", audioUrl: "audio/brazil/thankyou.mp3" },
              { text: "Tchau", translation: "Goodbye", audioUrl: "audio/brazil/goodbye.mp3" },
            ],
          },
        },
      },
      contents: {
        create: [
          {
            title: "Feijoada",
            contentType: ContentType.IMAGE_UPLOAD,
            contentUrl: "content/brazil/feijoada.jpg",
            category: ContentCategory.FOOD,
          },
        ],
      },
    },
  });

  // Create a pending nation for testing admin moderation
  const testPending = await prisma.nation.create({
    data: {
      name: "Test Pending Nation",
      slug: "test-pending",
      state: NationState.pending,
      description: "A test nation pending approval.",
    },
  });

  console.log("Seeded:", {
    adminUser: adminUser.id,
    japan: japan.id,
    brazil: brazil.id,
    testPending: testPending.id,
  });
}

main()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
```

**Step 2: Add seed script to package.json**

Add to `package.json`:

```json
{
  "prisma": {
    "seed": "npx tsx prisma/seed.ts"
  }
}
```

**Step 3: Install tsx for running TypeScript**

Run:

```bash
npm install -D tsx
```

**Step 4: Run seed**

Run:

```bash
npx prisma db seed
```

Expected: Output shows seeded nation IDs

**Step 5: Commit**

```bash
git add .
git commit -m "feat: add database seed with sample nations and admin user"
```

---

## Phase 3: API Routes

### Task 10: Create Nations API - GET All (Public: approved only)

**Files:**

- Create: `src/app/api/nations/route.ts`
- Create: `src/lib/validations/nation.ts`

**Step 1: Create validation schemas**

```typescript
// src/lib/validations/nation.ts
import { z } from "zod";

export const nationQuerySchema = z.object({
  search: z.string().optional(),
  state: z.enum(["approved", "pending"]).optional(),
  limit: z.coerce.number().min(1).max(100).default(50),
  offset: z.coerce.number().min(0).default(0),
});

export const nationSubmitSchema = z.object({
  name: z.string().min(1).max(100),
  description: z.string().optional(),
  boundaryGeoJson: z.string().optional(), // GeoJSON string with MultiPolygon geometry
});

export const nationUpdateSchema = z.object({
  name: z.string().min(1).max(100).optional(),
  description: z.string().optional(),
  flagUrl: z.string().optional(),
  boundaryGeoJson: z.string().optional(),
  state: z.enum(["approved", "pending"]).optional(),
});

export type NationQuery = z.infer<typeof nationQuerySchema>;
export type NationSubmit = z.infer<typeof nationSubmitSchema>;
export type NationUpdate = z.infer<typeof nationUpdateSchema>;
```

**Step 2: Create GET/POST /api/nations route**

```typescript
// src/app/api/nations/route.ts
import { NextRequest, NextResponse } from "next/server";
import { db } from "@/lib/db";
import {
  nationQuerySchema,
  nationSubmitSchema,
} from "@/lib/validations/nation";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";

// GET: Public - returns only approved nations (for map display)
export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const query = nationQuerySchema.parse({
      search: searchParams.get("search") ?? undefined,
      limit: searchParams.get("limit") ?? undefined,
      offset: searchParams.get("offset") ?? undefined,
    });

    // Public API only returns approved nations
    const where = {
      state: "approved" as const,
      ...(query.search && {
        OR: [
          { name: { contains: query.search, mode: "insensitive" as const } },
          {
            languages: {
              some: {
                name: { contains: query.search, mode: "insensitive" as const },
              },
            },
          },
        ],
      }),
    };

    const [nations, total] = await Promise.all([
      db.nation.findMany({
        where,
        select: {
          id: true,
          name: true,
          slug: true,
          flagUrl: true,
          boundaryGeoJson: true,
        },
        orderBy: { name: "asc" },
        take: query.limit,
        skip: query.offset,
      }),
      db.nation.count({ where }),
    ]);

    return NextResponse.json({
      nations,
      pagination: { total, limit: query.limit, offset: query.offset },
    });
  } catch (error) {
    console.error("GET /api/nations error:", error);
    return NextResponse.json(
      { error: "Failed to fetch nations" },
      { status: 500 },
    );
  }
}

// POST: Anyone can submit a new nation (created as pending)
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const data = nationSubmitSchema.parse(body);

    // Generate slug from name
    const slug = data.name
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, "-")
      .replace(/^-|-$/g, "");

    // Check if slug already exists
    const existing = await db.nation.findUnique({ where: { slug } });
    if (existing) {
      return NextResponse.json(
        { error: "A nation with this name already exists" },
        { status: 409 },
      );
    }

    // Get current user if authenticated (optional)
    const session = await getServerSession(authOptions);

    const nation = await db.nation.create({
      data: {
        ...data,
        slug,
        state: "pending", // Always starts as pending
        submittedById: session?.user?.id ?? null,
      },
      select: { id: true, name: true, slug: true, state: true },
    });

    return NextResponse.json(nation, { status: 201 });
  } catch (error) {
    console.error("POST /api/nations error:", error);
    if (error instanceof Error && error.message.includes("Unique constraint")) {
      return NextResponse.json(
        { error: "Nation with this name already exists" },
        { status: 409 },
      );
    }
    return NextResponse.json(
      { error: "Failed to submit nation" },
      { status: 500 },
    );
  }
}
```

**Step 3: Commit**

```bash
git add .
git commit -m "feat: add GET/POST /api/nations - public only shows approved"
```

---

### Task 11: Create Nations API - GET Single with Full Details

**Files:**

- Create: `src/app/api/nations/[slug]/route.ts`

**Step 1: Create GET /api/nations/[slug] route**

```typescript
// src/app/api/nations/[slug]/route.ts
import { NextRequest, NextResponse } from "next/server";
import { db } from "@/lib/db";

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ slug: string }> },
) {
  try {
    const { slug } = await params;

    const nation = await db.nation.findUnique({
      where: { slug },
      include: {
        languages: {
          include: { phrases: true },
        },
        contents: true,
        submittedBy: {
          select: { firstName: true, lastName: true },
        },
      },
    });

    if (!nation) {
      return NextResponse.json({ error: "Nation not found" }, { status: 404 });
    }

    // Only return if approved (public access)
    // Admin routes will have separate access
    if (nation.state !== "approved") {
      return NextResponse.json({ error: "Nation not found" }, { status: 404 });
    }

    return NextResponse.json(nation);
  } catch (error) {
    console.error("GET /api/nations/[slug] error:", error);
    return NextResponse.json(
      { error: "Failed to fetch nation" },
      { status: 500 },
    );
  }
}
```

**Step 2: Commit**

```bash
git add .
git commit -m "feat: add GET /api/nations/[slug] for full nation details"
```

---

### Task 12: Create GeoJSON API for Map (approved only)

**Files:**

- Create: `src/app/api/nations/geojson/route.ts`

**Step 1: Create GeoJSON endpoint**

```typescript
// src/app/api/nations/geojson/route.ts
import { NextResponse } from "next/server";
import { db } from "@/lib/db";

export async function GET() {
  try {
    // Only return approved nations for public map
    const nations = await db.nation.findMany({
      where: {
        state: "approved",
        boundaryGeoJson: { not: null },
      },
      select: {
        id: true,
        name: true,
        slug: true,
        flagUrl: true,
        boundaryGeoJson: true,
      },
    });

    const features = nations
      .map((nation) => {
        try {
          const geoJson = nation.boundaryGeoJson
            ? JSON.parse(nation.boundaryGeoJson)
            : null;

          return {
            type: "Feature",
            id: nation.id,
            properties: {
              id: nation.id,
              name: nation.name,
              slug: nation.slug,
              flagUrl: nation.flagUrl,
            },
            geometry: geoJson?.geometry,
          };
        } catch {
          return null;
        }
      })
      .filter((f) => f !== null && f.geometry !== undefined);

    return NextResponse.json({
      type: "FeatureCollection",
      features,
    });
  } catch (error) {
    console.error("GET /api/nations/geojson error:", error);
    return NextResponse.json(
      { error: "Failed to fetch GeoJSON" },
      { status: 500 },
    );
  }
}
```

**Step 2: Commit**

```bash
git add .
git commit -m "feat: add GET /api/nations/geojson for map data (approved only)"
```

---

### Task 13: Create Admin API Routes

**Files:**

- Create: `src/app/api/admin/nations/route.ts`
- Create: `src/app/api/admin/nations/[id]/route.ts`
- Create: `src/lib/admin.ts`

**Step 1: Create admin helper**

```typescript
// src/lib/admin.ts
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { NextResponse } from "next/server";

export async function requireAdmin() {
  const session = await getServerSession(authOptions);

  if (!session?.user) {
    return {
      error: NextResponse.json({ error: "Unauthorized" }, { status: 401 }),
    };
  }

  if (!session.user.isAdmin) {
    return {
      error: NextResponse.json({ error: "Forbidden" }, { status: 403 }),
    };
  }

  return { session };
}
```

**Step 2: Create admin nations list API**

```typescript
// src/app/api/admin/nations/route.ts
import { NextRequest, NextResponse } from "next/server";
import { db } from "@/lib/db";
import { requireAdmin } from "@/lib/admin";
import { nationQuerySchema } from "@/lib/validations/nation";

// GET: Admin - list all nations with optional state filter
export async function GET(request: NextRequest) {
  const { error } = await requireAdmin();
  if (error) return error;

  try {
    const searchParams = request.nextUrl.searchParams;
    const query = nationQuerySchema.parse({
      search: searchParams.get("search") ?? undefined,
      state: searchParams.get("state") ?? undefined,
      limit: searchParams.get("limit") ?? undefined,
      offset: searchParams.get("offset") ?? undefined,
    });

    const where = {
      ...(query.state && { state: query.state }),
      ...(query.search && {
        OR: [
          { name: { contains: query.search, mode: "insensitive" as const } },
        ],
      }),
    };

    const [nations, total] = await Promise.all([
      db.nation.findMany({
        where,
        select: {
          id: true,
          name: true,
          slug: true,
          state: true,
          description: true,
          createdAt: true,
          submittedBy: {
            select: { email: true, firstName: true, lastName: true },
          },
        },
        orderBy: { createdAt: "desc" },
        take: query.limit,
        skip: query.offset,
      }),
      db.nation.count({ where }),
    ]);

    return NextResponse.json({
      nations,
      pagination: { total, limit: query.limit, offset: query.offset },
    });
  } catch (error) {
    console.error("GET /api/admin/nations error:", error);
    return NextResponse.json(
      { error: "Failed to fetch nations" },
      { status: 500 },
    );
  }
}
```

**Step 3: Create admin nation actions API**

```typescript
// src/app/api/admin/nations/[id]/route.ts
import { NextRequest, NextResponse } from "next/server";
import { db } from "@/lib/db";
import { requireAdmin } from "@/lib/admin";
import { nationUpdateSchema } from "@/lib/validations/nation";

// GET: Admin - get full nation details (including pending)
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> },
) {
  const { error } = await requireAdmin();
  if (error) return error;

  try {
    const { id } = await params;

    const nation = await db.nation.findUnique({
      where: { id },
      include: {
        languages: { include: { phrases: true } },
        contents: true,
        submittedBy: {
          select: { email: true, firstName: true, lastName: true },
        },
      },
    });

    if (!nation) {
      return NextResponse.json({ error: "Nation not found" }, { status: 404 });
    }

    return NextResponse.json(nation);
  } catch (error) {
    console.error("GET /api/admin/nations/[id] error:", error);
    return NextResponse.json(
      { error: "Failed to fetch nation" },
      { status: 500 },
    );
  }
}

// PATCH: Admin - update nation (approve/reject)
export async function PATCH(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> },
) {
  const { error } = await requireAdmin();
  if (error) return error;

  try {
    const { id } = await params;
    const body = await request.json();
    const data = nationUpdateSchema.parse(body);

    const nation = await db.nation.update({
      where: { id },
      data,
      select: { id: true, name: true, slug: true, state: true },
    });

    return NextResponse.json(nation);
  } catch (error) {
    console.error("PATCH /api/admin/nations/[id] error:", error);
    return NextResponse.json(
      { error: "Failed to update nation" },
      { status: 500 },
    );
  }
}

// DELETE: Admin - delete nation
export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> },
) {
  const { error } = await requireAdmin();
  if (error) return error;

  try {
    const { id } = await params;

    await db.nation.delete({ where: { id } });

    return new NextResponse(null, { status: 204 });
  } catch (error) {
    console.error("DELETE /api/admin/nations/[id] error:", error);
    return NextResponse.json(
      { error: "Failed to delete nation" },
      { status: 500 },
    );
  }
}
```

**Step 4: Commit**

```bash
git add .
git commit -m "feat: add admin API routes for nation moderation"
```

---

### Task 14: Create Spatial Query API for Overlapping Regions

**Files:**

- Create: `src/app/api/nations/at-point/route.ts`

**Step 1: Create point query endpoint**

```typescript
// src/app/api/nations/at-point/route.ts
import { NextRequest, NextResponse } from "next/server";
import { db } from "@/lib/db";

// GET: Find all approved nations at a given point (for overlapping regions)
export async function GET(request: NextRequest) {
  try {
    const lng = request.nextUrl.searchParams.get("lng");
    const lat = request.nextUrl.searchParams.get("lat");

    if (!lng || !lat) {
      return NextResponse.json(
        { error: "lng and lat query parameters are required" },
        { status: 400 },
      );
    }

    const longitude = parseFloat(lng);
    const latitude = parseFloat(lat);

    if (isNaN(longitude) || isNaN(latitude)) {
      return NextResponse.json(
        { error: "Invalid coordinates" },
        { status: 400 },
      );
    }

    // Use raw SQL for PostGIS spatial query
    const nations = await db.$queryRaw<
      Array<{ id: string; name: string; slug: string; flagUrl: string | null }>
    >`
      SELECT id, name, slug, "flagUrl"
      FROM "Nation"
      WHERE state = 'approved'
        AND boundary IS NOT NULL
        AND ST_Contains(boundary, ST_SetSRID(ST_Point(${longitude}, ${latitude}), 4326))
      ORDER BY name ASC
    `;

    return NextResponse.json({ nations });
  } catch (error) {
    console.error("GET /api/nations/at-point error:", error);
    return NextResponse.json(
      { error: "Failed to query nations at point" },
      { status: 500 },
    );
  }
}
```

**Step 2: Commit**

```bash
git add .
git commit -m "feat: add spatial query API for overlapping nation regions"
```

---

### Task 15: Create Media Upload API with MinIO

**Files:**

- Create: `src/app/api/upload/route.ts`
- Create: `src/lib/minio.ts`
- Create: `src/lib/media-url.ts`

**Step 1: Install MinIO SDK**

Run:

```bash
npm install minio
```

**Step 2: Create MinIO client utility**

```typescript
// src/lib/minio.ts
import { Client } from "minio";

const MAX_FILE_SIZE =
  parseInt(process.env.MAX_FILE_SIZE_MB || "50") * 1024 * 1024;

const ALLOWED_TYPES: Record<string, string[]> = {
  image: [
    "image/jpeg",
    "image/png",
    "image/webp",
    "image/svg+xml",
    "image/gif",
  ],
  audio: ["audio/mpeg", "audio/wav", "audio/ogg", "audio/mp3"],
  video: ["video/mp4", "video/webm", "video/ogg"],
};

const minioClient = new Client({
  endPoint: process.env.MINIO_ENDPOINT?.split(":")[0] || "localhost",
  port: parseInt(process.env.MINIO_ENDPOINT?.split(":")[1] || "9000"),
  useSSL: process.env.MINIO_USE_SSL === "true",
  accessKey: process.env.MINIO_ACCESS_KEY || "cultures",
  secretKey: process.env.MINIO_SECRET_KEY || "cultures_dev_password",
});

const BUCKET = process.env.MINIO_BUCKET || "cultures";

export async function ensureBucket(): Promise<void> {
  const exists = await minioClient.bucketExists(BUCKET);
  if (!exists) {
    await minioClient.makeBucket(BUCKET);
    const policy = {
      Version: "2012-10-17",
      Statement: [
        {
          Effect: "Allow",
          Principal: { AWS: ["*"] },
          Action: ["s3:GetObject"],
          Resource: [`arn:aws:s3:::${BUCKET}/*`],
        },
      ],
    };
    await minioClient.setBucketPolicy(BUCKET, JSON.stringify(policy));
  }
}

export async function uploadFile(
  file: File,
  category: string,
  nationSlug: string,
): Promise<{ key: string; url: string }> {
  const buffer = Buffer.from(await file.arrayBuffer());

  if (buffer.length > MAX_FILE_SIZE) {
    throw new Error(
      `File too large. Maximum size is ${MAX_FILE_SIZE / 1024 / 1024}MB`,
    );
  }

  const mediaType = Object.entries(ALLOWED_TYPES).find(([, types]) =>
    types.includes(file.type),
  )?.[0];

  if (!mediaType) {
    throw new Error(`Unsupported file type: ${file.type}`);
  }

  await ensureBucket();

  const ext = file.name.split(".").pop() || "bin";
  const filename = `${Date.now()}-${Math.random().toString(36).slice(2)}.${ext}`;
  const key = `${category}/${nationSlug}/${filename}`;

  await minioClient.putObject(BUCKET, key, buffer, buffer.length, {
    "Content-Type": file.type,
  });

  return { key, url: key };
}

export async function deleteFile(key: string): Promise<void> {
  await minioClient.removeObject(BUCKET, key);
}
```

**Step 3: Create media URL helper**

```typescript
// src/lib/media-url.ts

export function getMediaUrl(key: string | null): string {
  if (!key) return "";

  if (key.startsWith("http://") || key.startsWith("https://")) {
    return key;
  }

  const endpoint = process.env.NEXT_PUBLIC_MINIO_ENDPOINT || "localhost:9000";
  const bucket = process.env.NEXT_PUBLIC_MINIO_BUCKET || "cultures";
  const protocol =
    process.env.NEXT_PUBLIC_MINIO_USE_SSL === "true" ? "https" : "http";

  return `${protocol}://${endpoint}/${bucket}/${key}`;
}
```

**Step 4: Create upload API route**

```typescript
// src/app/api/upload/route.ts
import { NextRequest, NextResponse } from "next/server";
import { uploadFile } from "@/lib/minio";

export async function POST(request: NextRequest) {
  try {
    const formData = await request.formData();
    const file = formData.get("file") as File | null;
    const category = formData.get("category") as string | null;
    const nationSlug = formData.get("nationSlug") as string | null;

    if (!file) {
      return NextResponse.json({ error: "No file provided" }, { status: 400 });
    }

    if (!category || !nationSlug) {
      return NextResponse.json(
        { error: "Category and nationSlug are required" },
        { status: 400 },
      );
    }

    const validCategories = ["flags", "audio", "content"];
    if (!validCategories.includes(category)) {
      return NextResponse.json(
        {
          error: `Invalid category. Must be one of: ${validCategories.join(", ")}`,
        },
        { status: 400 },
      );
    }

    const result = await uploadFile(file, category, nationSlug);

    return NextResponse.json(
      {
        key: result.key,
        url: result.url,
        filename: file.name,
        size: file.size,
        type: file.type,
      },
      { status: 201 },
    );
  } catch (error) {
    console.error("POST /api/upload error:", error);
    const message =
      error instanceof Error ? error.message : "Failed to upload file";
    return NextResponse.json({ error: message }, { status: 500 });
  }
}
```

**Step 5: Commit**

```bash
git add .
git commit -m "feat: add media upload API with MinIO storage"
```

---

## Phase 4: Frontend Components

### Task 16: Create Map Component (Globe Projection)

**Files:**

- Create: `src/components/map/world-map.tsx`
- Create: `src/components/map/map-styles.css`
- Create: `src/stores/map-store.ts`

**Step 1: Create map store using Zustand**

```typescript
// src/stores/map-store.ts
import { create } from "zustand";
import type { Map } from "maplibre-gl";

interface MapState {
  mapInstance: Map | null;
  isDrawingMode: boolean;
  drawnPolygon: GeoJSON.Feature<GeoJSON.Polygon> | null;
  setMapInstance: (map: Map | null) => void;
  setIsDrawingMode: (isDrawing: boolean) => void;
  setDrawnPolygon: (polygon: GeoJSON.Feature<GeoJSON.Polygon> | null) => void;
  zoomIn: () => void;
  zoomOut: () => void;
  locateMe: () => void;
}

export const useMapStore = create<MapState>((set, get) => ({
  mapInstance: null,
  isDrawingMode: false,
  drawnPolygon: null,
  setMapInstance: (map) => set({ mapInstance: map }),
  setIsDrawingMode: (isDrawing) => set({ isDrawingMode: isDrawing }),
  setDrawnPolygon: (polygon) => set({ drawnPolygon: polygon }),
  zoomIn: () => {
    const { mapInstance } = get();
    if (mapInstance) {
      mapInstance.zoomIn({ duration: 300 });
    }
  },
  zoomOut: () => {
    const { mapInstance } = get();
    if (mapInstance) {
      mapInstance.zoomOut({ duration: 300 });
    }
  },
  locateMe: () => {
    const { mapInstance } = get();
    if (mapInstance && navigator.geolocation) {
      navigator.geolocation.getCurrentPosition(
        (position) => {
          mapInstance.flyTo({
            center: [position.coords.longitude, position.coords.latitude],
            zoom: 10,
            duration: 2000,
          });
        },
        (error) => {
          console.error("Geolocation error:", error);
        }
      );
    }
  },
}));
```

**Step 2: Install Zustand**

```bash
npm install zustand
```

**Step 3: Create map CSS**

```css
/* src/components/map/map-styles.css */
.maplibregl-map {
  width: 100%;
  height: 100%;
}

.maplibregl-popup-content {
  padding: 0;
  border-radius: 8px;
  overflow: hidden;
}

.nation-popup {
  padding: 12px;
  min-width: 150px;
}

.nation-popup h3 {
  margin: 0 0 4px 0;
  font-size: 14px;
  font-weight: 600;
}

/* Globe atmosphere effect */
.maplibregl-map.globe-view {
  background: radial-gradient(circle at center, #87CEEB 0%, #1a1a2e 100%);
}
```

**Step 4: Create WorldMap component with GLOBE projection**

```typescript
// src/components/map/world-map.tsx
"use client";

import { useEffect, useRef, useCallback, useState } from "react";
import maplibregl, { Map, MapMouseEvent, LngLat } from "maplibre-gl";
import "maplibre-gl/dist/maplibre-gl.css";
import "./map-styles.css";
import { useMapStore } from "@/stores/map-store";

interface NationAtPoint {
  id: string;
  name: string;
  slug: string;
  flagUrl: string | null;
}

interface WorldMapProps {
  onNationClick: (slug: string) => void;
  onMultipleNationsAtPoint: (nations: NationAtPoint[], lngLat: LngLat) => void;
}

export function WorldMap({ onNationClick, onMultipleNationsAtPoint }: WorldMapProps) {
  const mapContainer = useRef<HTMLDivElement>(null);
  const map = useRef<Map | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const { setMapInstance, isDrawingMode } = useMapStore();

  const handleMapClick = useCallback(
    async (e: MapMouseEvent) => {
      // Skip if in drawing mode
      if (isDrawingMode) return;

      const { lng, lat } = e.lngLat;

      try {
        // Query all nations at this point (handles overlapping regions)
        const response = await fetch(`/api/nations/at-point?lng=${lng}&lat=${lat}`);
        const data = await response.json();

        if (data.nations && data.nations.length > 0) {
          if (data.nations.length === 1) {
            // Single nation - open modal directly
            onNationClick(data.nations[0].slug);
          } else {
            // Multiple overlapping nations - show selection popup
            onMultipleNationsAtPoint(data.nations, e.lngLat);
          }
        }
      } catch (error) {
        console.error("Failed to query nations at point:", error);
      }
    },
    [onNationClick, onMultipleNationsAtPoint, isDrawingMode]
  );

  useEffect(() => {
    if (!mapContainer.current || map.current) return;

    const mapStyle =
      process.env.NEXT_PUBLIC_MAP_STYLE || "https://tiles.openfreemap.org/styles/liberty";

    map.current = new maplibregl.Map({
      container: mapContainer.current,
      style: mapStyle,
      center: [0, 20],
      zoom: 1.5,
      minZoom: 1,
      maxZoom: 18,
    });

    const mapInstance = map.current;

    // Set GLOBE projection for 3D globe view
    mapInstance.setProjection({ type: "globe" });

    const mapInstance = map.current;

    mapInstance.on("load", async () => {
      try {
        const response = await fetch("/api/nations/geojson");
        const geojson = await response.json();

        mapInstance.addSource("nations", {
          type: "geojson",
          data: geojson,
        });

        // Add fill layer for nation boundaries
        mapInstance.addLayer({
          id: "nations-fill",
          type: "fill",
          source: "nations",
          paint: {
            "fill-color": "#3b82f6",
            "fill-opacity": 0.2,
          },
        });

        // Add outline layer
        mapInstance.addLayer({
          id: "nations-outline",
          type: "line",
          source: "nations",
          paint: {
            "line-color": "#3b82f6",
            "line-width": 2,
          },
        });

        // Hover effects
        mapInstance.on("mouseenter", "nations-fill", () => {
          mapInstance.getCanvas().style.cursor = "pointer";
        });

        mapInstance.on("mouseleave", "nations-fill", () => {
          mapInstance.getCanvas().style.cursor = "";
        });

        setIsLoading(false);
      } catch (error) {
        console.error("Failed to load nations GeoJSON:", error);
        setIsLoading(false);
      }
    });

    // Click handler for map
    mapInstance.on("click", handleMapClick);

    // Add navigation controls
    mapInstance.addControl(new maplibregl.NavigationControl(), "top-right");

    return () => {
      mapInstance.remove();
      map.current = null;
    };
  }, [handleMapClick]);

  return (
    <div className="relative w-full h-full" style={{ minHeight: "400px" }}>
      <div ref={mapContainer} className="w-full h-full" />
      {isLoading && (
        <div className="absolute inset-0 flex items-center justify-center bg-white/50">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500" />
        </div>
      )}
    </div>
  );
}
```

**Step 3: Commit**

```bash
git add .
git commit -m "feat: add WorldMap component with overlapping region handling"
```

---

### Task 17: Create Nation Selection Popup (for overlapping regions)

**Files:**

- Create: `src/components/map/nation-selection-popup.tsx`

**Step 1: Create selection popup component**

```typescript
// src/components/map/nation-selection-popup.tsx
"use client";

import { Paper, Text, UnstyledButton, Group, Stack } from "@mantine/core";
import { IconChevronRight } from "@tabler/icons-react";

interface Nation {
  id: string;
  name: string;
  slug: string;
  flagUrl: string | null;
}

interface NationSelectionPopupProps {
  nations: Nation[];
  position: { x: number; y: number };
  onSelect: (slug: string) => void;
  onClose: () => void;
}

export function NationSelectionPopup({
  nations,
  position,
  onSelect,
  onClose,
}: NationSelectionPopupProps) {
  return (
    <>
      {/* Backdrop */}
      <div
        className="fixed inset-0 z-40"
        onClick={onClose}
      />

      {/* Popup */}
      <Paper
        shadow="md"
        radius="md"
        className="fixed z-50 min-w-[200px] max-w-[300px]"
        style={{
          left: position.x,
          top: position.y,
          transform: "translate(-50%, -100%)",
          marginTop: -10,
        }}
      >
        <div className="p-2">
          <Text size="xs" c="dimmed" className="px-2 py-1">
            Multiple nations at this location
          </Text>
          <Stack gap={0}>
            {nations.map((nation) => (
              <UnstyledButton
                key={nation.id}
                onClick={() => {
                  onSelect(nation.slug);
                  onClose();
                }}
                className="w-full px-3 py-2 rounded hover:bg-gray-100 transition-colors"
              >
                <Group justify="space-between">
                  <Text size="sm" fw={500}>
                    {nation.name}
                  </Text>
                  <IconChevronRight size={16} className="text-gray-400" />
                </Group>
              </UnstyledButton>
            ))}
          </Stack>
        </div>
      </Paper>
    </>
  );
}
```

**Step 2: Commit**

```bash
git add .
git commit -m "feat: add nation selection popup for overlapping regions"
```

---

### Task 18: Create Nation Details Modal

**Files:**

- Create: `src/components/nation/nation-modal.tsx`
- Create: `src/components/nation/sections/languages-section.tsx`
- Create: `src/components/nation/sections/content-section.tsx`

**Step 1: Create LanguagesSection component (displays languages with their phrases)**

```typescript
// src/components/nation/sections/languages-section.tsx
"use client";

import { Card, Text, Group, Stack, Accordion } from "@mantine/core";
import { getMediaUrl } from "@/lib/media-url";

interface Phrase {
  id: string;
  text: string;
  translation: string;
  audioUrl: string;
}

interface Language {
  id: string;
  name: string;
  description: string;
  phrases: Phrase[];
}

interface LanguagesSectionProps {
  languages: Language[];
}

export function LanguagesSection({ languages }: LanguagesSectionProps) {
  if (languages.length === 0) {
    return (
      <Card withBorder>
        <Text c="dimmed">No language information available.</Text>
      </Card>
    );
  }

  return (
    <Accordion variant="separated">
      {languages.map((language) => (
        <Accordion.Item key={language.id} value={language.id}>
          <Accordion.Control>
            <Text fw={600}>{language.name}</Text>
          </Accordion.Control>
          <Accordion.Panel>
            <Stack gap="md">
              <Text size="sm" c="dimmed">{language.description}</Text>

              {language.phrases.length > 0 && (
                <div>
                  <Text fw={500} size="sm" mb="xs">Common Phrases</Text>
                  <Stack gap="sm">
                    {language.phrases.map((phrase) => (
                      <Card key={phrase.id} withBorder p="sm">
                        <Group justify="space-between" align="flex-start">
                          <div>
                            <Text fw={500} size="lg">{phrase.text}</Text>
                            <Text size="sm" c="dimmed">{phrase.translation}</Text>
                          </div>
                          <audio controls className="w-32 h-8">
                            <source src={getMediaUrl(phrase.audioUrl)} type="audio/mpeg" />
                          </audio>
                        </Group>
                      </Card>
                    ))}
                  </Stack>
                </div>
              )}
            </Stack>
          </Accordion.Panel>
        </Accordion.Item>
      ))}
    </Accordion>
  );
}
```

**Step 2: Create ContentSection component (displays all content by category)**

```typescript
// src/components/nation/sections/content-section.tsx
"use client";

import Image from "next/image";
import { Card, Text, Badge, Tabs } from "@mantine/core";
import { IconToolsKitchen2, IconMusic, IconPhoto } from "@tabler/icons-react";
import { getMediaUrl } from "@/lib/media-url";

interface Content {
  id: string;
  title: string;
  contentType: "IMAGE_UPLOAD" | "VIDEO_UPLOAD" | "VIDEO_YOUTUBE";
  contentUrl: string | null;
  category: "FOOD" | "MUSIC" | "OTHER";
}

interface ContentSectionProps {
  contents: Content[];
}

function getYouTubeEmbedUrl(url: string): string {
  const videoId = url.match(
    /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([^&\s]+)/
  )?.[1];
  return videoId ? `https://www.youtube.com/embed/${videoId}` : url;
}

function ContentCard({ item }: { item: Content }) {
  const isYouTube = item.contentType === "VIDEO_YOUTUBE";
  const isVideo = item.contentType === "VIDEO_UPLOAD";
  const isImage = item.contentType === "IMAGE_UPLOAD";

  return (
    <Card withBorder p={0} className="overflow-hidden">
      <div className="relative aspect-video bg-gray-100">
        {isYouTube && item.contentUrl && (
          <iframe
            src={getYouTubeEmbedUrl(item.contentUrl)}
            className="absolute inset-0 w-full h-full"
            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
            allowFullScreen
          />
        )}
        {isVideo && item.contentUrl && (
          <video controls className="absolute inset-0 w-full h-full object-contain">
            <source src={getMediaUrl(item.contentUrl)} type="video/mp4" />
          </video>
        )}
        {isImage && item.contentUrl && (
          <Image
            src={getMediaUrl(item.contentUrl)}
            alt={item.title}
            fill
            className="object-cover"
            sizes="(max-width: 768px) 100vw, 50vw"
          />
        )}
      </div>
      <div className="p-4">
        <div className="flex items-center gap-2">
          <Text fw={500}>{item.title}</Text>
          <Badge size="xs" variant="light">
            {item.contentType === "VIDEO_YOUTUBE" ? "YouTube" :
             item.contentType === "VIDEO_UPLOAD" ? "Video" : "Image"}
          </Badge>
        </div>
      </div>
    </Card>
  );
}

export function ContentSection({ contents }: ContentSectionProps) {
  if (contents.length === 0) {
    return (
      <Card withBorder>
        <Text c="dimmed">No content available.</Text>
      </Card>
    );
  }

  const foodContent = contents.filter((c) => c.category === "FOOD");
  const musicContent = contents.filter((c) => c.category === "MUSIC");
  const otherContent = contents.filter((c) => c.category === "OTHER");

  return (
    <Tabs defaultValue="all">
      <Tabs.List>
        <Tabs.Tab value="all">All ({contents.length})</Tabs.Tab>
        {foodContent.length > 0 && (
          <Tabs.Tab value="food" leftSection={<IconToolsKitchen2 size={14} />}>
            Food ({foodContent.length})
          </Tabs.Tab>
        )}
        {musicContent.length > 0 && (
          <Tabs.Tab value="music" leftSection={<IconMusic size={14} />}>
            Music ({musicContent.length})
          </Tabs.Tab>
        )}
        {otherContent.length > 0 && (
          <Tabs.Tab value="other" leftSection={<IconPhoto size={14} />}>
            Other ({otherContent.length})
          </Tabs.Tab>
        )}
      </Tabs.List>

      <Tabs.Panel value="all" pt="md">
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          {contents.map((item) => (
            <ContentCard key={item.id} item={item} />
          ))}
        </div>
      </Tabs.Panel>

      <Tabs.Panel value="food" pt="md">
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          {foodContent.map((item) => (
            <ContentCard key={item.id} item={item} />
          ))}
        </div>
      </Tabs.Panel>

      <Tabs.Panel value="music" pt="md">
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          {musicContent.map((item) => (
            <ContentCard key={item.id} item={item} />
          ))}
        </div>
      </Tabs.Panel>

      <Tabs.Panel value="other" pt="md">
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          {otherContent.map((item) => (
            <ContentCard key={item.id} item={item} />
          ))}
        </div>
      </Tabs.Panel>
    </Tabs>
  );
}
```

**Step 3: Create main NationModal component**

```typescript
// src/components/nation/nation-modal.tsx
"use client";

import { useEffect, useState } from "react";
import { Modal, Tabs, Text, Skeleton, Group, Title } from "@mantine/core";
import {
  IconLanguage,
  IconPhoto,
} from "@tabler/icons-react";
import { LanguagesSection } from "./sections/languages-section";
import { ContentSection } from "./sections/content-section";
import { getMediaUrl } from "@/lib/media-url";
import Image from "next/image";

interface NationModalProps {
  slug: string | null;
  onClose: () => void;
}

interface NationDetails {
  id: string;
  name: string;
  slug: string;
  description: string | null;
  flagUrl: string | null;
  languages: any[];
  contents: any[];
}

export function NationModal({ slug, onClose }: NationModalProps) {
  const [nation, setNation] = useState<NationDetails | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (!slug) return;

    setLoading(true);
    setError(null);

    fetch(`/api/nations/${slug}`)
      .then((res) => {
        if (!res.ok) throw new Error("Nation not found");
        return res.json();
      })
      .then((data) => setNation(data))
      .catch((err) => setError(err.message))
      .finally(() => setLoading(false));
  }, [slug]);

  return (
    <Modal
      opened={!!slug}
      onClose={onClose}
      size="xl"
      title={
        loading ? (
          <Skeleton height={24} width={200} />
        ) : nation ? (
          <Group gap="sm">
            {nation.flagUrl && (
              <div className="relative w-8 h-6">
                <Image
                  src={getMediaUrl(nation.flagUrl)}
                  alt={`${nation.name} flag`}
                  fill
                  className="object-cover rounded"
                />
              </div>
            )}
            <Title order={3}>{nation.name}</Title>
          </Group>
        ) : null
      }
      overlayProps={{ backgroundOpacity: 0.55, blur: 3 }}
    >
      {loading && (
        <div className="space-y-4">
          <Skeleton height={100} />
          <Skeleton height={200} />
        </div>
      )}

      {error && (
        <Text c="red" ta="center" py="xl">
          {error}
        </Text>
      )}

      {nation && !loading && (
        <div className="space-y-4">
          {/* Header info */}
          <div>
            {nation.description && (
              <Text size="sm" c="dimmed" mb="md">
                {nation.description}
              </Text>
            )}
          </div>

          {/* Tabbed content */}
          <Tabs defaultValue="languages">
            <Tabs.List>
              <Tabs.Tab value="languages" leftSection={<IconLanguage size={16} />}>
                Languages ({nation.languages.length})
              </Tabs.Tab>
              <Tabs.Tab value="content" leftSection={<IconPhoto size={16} />}>
                Content ({nation.contents.length})
              </Tabs.Tab>
            </Tabs.List>

            <div className="pt-4">
              <Tabs.Panel value="languages">
                <LanguagesSection languages={nation.languages} />
              </Tabs.Panel>
              <Tabs.Panel value="content">
                <ContentSection contents={nation.contents} />
              </Tabs.Panel>
            </div>
          </Tabs>
        </div>
      )}
    </Modal>
  );
}
```

**Step 4: Commit**

```bash
git add .
git commit -m "feat: add nation details modal with languages and content sections"
```

---

### Task 19: Create Nation Submission Form (with Polygon Drawing Support)

**Files:**

- Create: `src/components/nation/nation-submit-form.tsx`

**Step 1: Create submission form component**

This form accepts an optional `initialBoundary` prop that gets pre-filled when the user draws a polygon on the map.

```typescript
// src/components/nation/nation-submit-form.tsx
"use client";

import { useState, useEffect } from "react";
import {
  Modal,
  TextInput,
  Textarea,
  Button,
  Stack,
  Text,
  Alert,
  Badge,
  Group,
} from "@mantine/core";
import { useForm } from "@mantine/form";
import { IconAlertCircle, IconCheck, IconMapPin } from "@tabler/icons-react";

interface NationSubmitFormProps {
  opened: boolean;
  onClose: () => void;
  initialBoundary?: GeoJSON.Feature<GeoJSON.Polygon> | null;
}


export function NationSubmitForm({ opened, onClose, initialBoundary }: NationSubmitFormProps) {
  const [submitting, setSubmitting] = useState(false);
  const [success, setSuccess] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const form = useForm({
    initialValues: {
      name: "",
      description: "",
      boundaryGeoJson: "",
    },
    validate: {
      name: (value) => (value.trim().length < 2 ? "Name must be at least 2 characters" : null),
    },
  });

  // Pre-fill boundary when polygon is drawn on map
  useEffect(() => {
    if (initialBoundary) {
      // Convert Polygon to MultiPolygon for consistency with schema
      const multiPolygonFeature = {
        type: "Feature",
        properties: {},
        geometry: {
          type: "MultiPolygon",
          coordinates: [initialBoundary.geometry.coordinates],
        },
      };
      form.setFieldValue("boundaryGeoJson", JSON.stringify(multiPolygonFeature, null, 2));
    }
  }, [initialBoundary]);

  // Reset form when modal closes
  useEffect(() => {
    if (!opened) {
      form.reset();
      setSuccess(false);
      setError(null);
    }
  }, [opened]);

  const handleSubmit = async (values: typeof form.values) => {
    setSubmitting(true);
    setError(null);

    try {
      const response = await fetch("/api/nations", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          ...values,
          boundaryGeoJson: values.boundaryGeoJson || undefined,
        }),
      });

      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.error || "Failed to submit nation");
      }

      setSuccess(true);
      form.reset();
      setTimeout(() => {
        setSuccess(false);
        onClose();
      }, 2000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "An error occurred");
    } finally {
      setSubmitting(false);
    }
  };

  const hasBoundary = !!form.values.boundaryGeoJson;

  return (
    <Modal
      opened={opened}
      onClose={onClose}
      title="Submit a New Nation"
      size="lg"
    >
      {success ? (
        <Alert icon={<IconCheck size={16} />} color="green" title="Success!">
          Your nation has been submitted and is pending review by our moderators.
        </Alert>
      ) : (
        <form onSubmit={form.onSubmit(handleSubmit)}>
          <Stack gap="md">
            {error && (
              <Alert icon={<IconAlertCircle size={16} />} color="red" title="Error">
                {error}
              </Alert>
            )}

            <Text size="sm" c="dimmed">
              Anyone can submit a nation. Submissions will be reviewed by moderators before appearing on the map.
            </Text>

            {/* Show boundary status */}
            {hasBoundary && (
              <Group gap="xs">
                <Badge leftSection={<IconMapPin size={12} />} color="green" variant="light">
                  Boundary drawn on map
                </Badge>
              </Group>
            )}

            <TextInput
              label="Nation Name"
              placeholder="Enter the nation's name"
              required
              {...form.getInputProps("name")}
            />

            <Textarea
              label="Description"
              placeholder="Describe this nation's history and culture"
              rows={4}
              {...form.getInputProps("description")}
            />

            <Textarea
              label="Boundary GeoJSON"
              placeholder={hasBoundary ? "Boundary captured from map drawing" : "Paste GeoJSON with MultiPolygon geometry"}
              rows={4}
              {...form.getInputProps("boundaryGeoJson")}
              description={hasBoundary ? "Automatically filled from your map drawing" : "Advanced: Paste valid GeoJSON with MultiPolygon geometry for map display"}
              disabled={!!initialBoundary}
            />

            <Button type="submit" loading={submitting} fullWidth>
              Submit Nation
            </Button>
          </Stack>
        </form>
      )}
    </Modal>
  );
}
```

**Step 2: Commit**

```bash
git add .
git commit -m "feat: add nation submission form for public submissions"
```

---

### Task 20: Create Main Page with Map, Right-Side Controls, and Add Nation Button

**Files:**

- Modify: `src/app/page.tsx`
- Create: `src/components/controls/main-page-controls.tsx`
- Create: `src/components/controls/styles.css`
- Create: `src/components/controls/add-nation-button.tsx`
- Create: `src/components/map/polygon-draw.tsx`

**Step 1: Create MainPageControls component (right sidebar)**

Based on whopins controls, excluding 'Add Pin', 'Remove Pin', and 'Import from Google'.

```css
/* src/components/controls/styles.css */
.main-page-controls-container {
  position: fixed;
  right: 0;
  top: 0;
  bottom: 0;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  align-items: flex-end;
  pointer-events: none;
  z-index: 2;

  & nav {
    pointer-events: auto;
  }
}

.dark {
  @mixin dark {
    display: none;
  }

  @mixin light {
    display: block;
  }
}

.light {
  @mixin light {
    display: none;
  }

  @mixin dark {
    display: block;
  }
}
```

```typescript
// src/components/controls/main-page-controls.tsx
"use client";

import { useState } from "react";
import {
  IconPlus,
  IconMinus,
  IconSun,
  IconMoon,
  IconInfoCircle,
  IconCurrentLocation,
  IconUser,
  IconLogout,
} from "@tabler/icons-react";
import {
  ActionIcon,
  Tooltip,
  useMantineColorScheme,
  useComputedColorScheme,
  Avatar,
  Button,
  Menu,
} from "@mantine/core";
import { useMediaQuery } from "@mantine/hooks";
import { useSession, signIn, signOut } from "next-auth/react";
import { useMapStore } from "@/stores/map-store";
import "./styles.css";

const toolTipStyles = {
  position: "left" as const,
  openDelay: 500,
};

function useIconStyles() {
  const isMobile = useMediaQuery("(max-width: 600px)");

  const actionIconStyles = {
    variant: "main-page-control" as const,
    size: isMobile ? "lg" : "xl",
    radius: "lg" as const,
  };

  const iconStyles = {
    size: isMobile ? 20 : 24,
    stroke: 1.5,
  };
  return { actionIconStyles, iconStyles };
}

function TopControls() {
  const { data: session, status } = useSession();
  const [profileMenuOpen, setProfileMenuOpen] = useState(false);
  const { iconStyles } = useIconStyles();

  const handleLogout = () => {
    signOut();
    setProfileMenuOpen(false);
  };

  return (
    <nav className="top-controls mt-2">
      <ActionIcon.Group orientation="vertical">
        <div className="h-[40px]">
          {status === "authenticated" && session?.user && (
            <Menu
              opened={profileMenuOpen}
              onChange={setProfileMenuOpen}
              position="left"
              shadow="md"
              withArrow
            >
              <Menu.Target>
                <Tooltip {...toolTipStyles} label="My Profile" disabled={profileMenuOpen}>
                  <Avatar
                    src={session.user.image}
                    radius="xl"
                    size={iconStyles.size + 20}
                    alt="User profile"
                    style={{ cursor: "pointer" }}
                    name={session.user.email || ""}
                  />
                </Tooltip>
              </Menu.Target>

              <Menu.Dropdown>
                <Menu.Item leftSection={<IconUser size={14} />}>
                  My Profile
                </Menu.Item>
                <Menu.Divider />
                <Menu.Item
                  color="red"
                  onClick={handleLogout}
                  leftSection={<IconLogout size={14} />}
                >
                  Log out
                </Menu.Item>
              </Menu.Dropdown>
            </Menu>
          )}
          {status === "unauthenticated" && (
            <Tooltip {...toolTipStyles} label="Sign In">
              <Button
                variant="main-page-control"
                size="sm"
                onClick={() => signIn("google")}
                radius="md"
              >
                Sign in
              </Button>
            </Tooltip>
          )}
        </div>
      </ActionIcon.Group>
    </nav>
  );
}

function MiddleControls() {
  const { actionIconStyles, iconStyles } = useIconStyles();
  const { setColorScheme } = useMantineColorScheme();
  const computedColorScheme = useComputedColorScheme("light", {
    getInitialValueInEffect: true,
  });

  return (
    <nav>
      <ActionIcon.Group orientation="vertical">
        <Tooltip {...toolTipStyles} label="About this app">
          <ActionIcon {...actionIconStyles} aria-label="Info">
            <IconInfoCircle {...iconStyles} />
          </ActionIcon>
        </Tooltip>
        <Tooltip {...toolTipStyles} label="Change theme">
          <ActionIcon
            {...actionIconStyles}
            onClick={() =>
              setColorScheme(computedColorScheme === "light" ? "dark" : "light")
            }
            aria-label="Change theme"
          >
            <IconSun {...iconStyles} className="light" />
            <IconMoon {...iconStyles} className="dark" />
          </ActionIcon>
        </Tooltip>
      </ActionIcon.Group>
    </nav>
  );
}

function BottomControls() {
  const { zoomIn, zoomOut, locateMe } = useMapStore();
  const { actionIconStyles, iconStyles } = useIconStyles();

  return (
    <nav className="mb-2">
      <ActionIcon.Group orientation="vertical">
        <Tooltip {...toolTipStyles} label="Zoom in">
          <ActionIcon {...actionIconStyles} onClick={zoomIn} aria-label="Zoom in">
            <IconPlus {...iconStyles} />
          </ActionIcon>
        </Tooltip>
        <Tooltip {...toolTipStyles} label="Zoom out">
          <ActionIcon {...actionIconStyles} onClick={zoomOut} aria-label="Zoom out">
            <IconMinus {...iconStyles} />
          </ActionIcon>
        </Tooltip>
        <Tooltip {...toolTipStyles} label="Locate me">
          <ActionIcon {...actionIconStyles} onClick={locateMe} aria-label="Locate me">
            <IconCurrentLocation {...iconStyles} />
          </ActionIcon>
        </Tooltip>
      </ActionIcon.Group>
    </nav>
  );
}

export function MainPageControls() {
  return (
    <div className="main-page-controls-container mr-2">
      <TopControls />
      <MiddleControls />
      <BottomControls />
    </div>
  );
}
```

**Step 2: Create Add Nation Button (bottom center)**

```typescript
// src/components/controls/add-nation-button.tsx
"use client";

import { ActionIcon, Tooltip } from "@mantine/core";
import { IconPlus } from "@tabler/icons-react";
import { useMapStore } from "@/stores/map-store";

interface AddNationButtonProps {
  onStartDrawing: () => void;
}

export function AddNationButton({ onStartDrawing }: AddNationButtonProps) {
  const { isDrawingMode } = useMapStore();

  return (
    <div className="fixed bottom-6 left-1/2 -translate-x-1/2 z-10">
      <Tooltip
        label={isDrawingMode ? "Drawing in progress..." : "Add a new nation"}
        position="top"
      >
        <ActionIcon
          size="xl"
          radius="xl"
          variant="filled"
          color="blue"
          onClick={onStartDrawing}
          disabled={isDrawingMode}
          className="shadow-lg hover:shadow-xl transition-shadow"
          aria-label="Add nation"
        >
          <IconPlus size={28} stroke={2} />
        </ActionIcon>
      </Tooltip>
    </div>
  );
}
```

**Step 3: Create Polygon Drawing Component**

```typescript
// src/components/map/polygon-draw.tsx
"use client";

import { useEffect, useRef, useCallback } from "react";
import { Button, Paper, Text, Group } from "@mantine/core";
import { IconCheck, IconX } from "@tabler/icons-react";
import { useMapStore } from "@/stores/map-store";
import type { Map, LngLat } from "maplibre-gl";

interface PolygonDrawProps {
  onComplete: (geojson: GeoJSON.Feature<GeoJSON.Polygon>) => void;
  onCancel: () => void;
}

export function PolygonDraw({ onComplete, onCancel }: PolygonDrawProps) {
  const { mapInstance, isDrawingMode, setIsDrawingMode, setDrawnPolygon } = useMapStore();
  const pointsRef = useRef<LngLat[]>([]);
  const sourceId = "drawing-polygon";
  const lineSourceId = "drawing-line";

  const updatePolygonOnMap = useCallback(() => {
    if (!mapInstance || pointsRef.current.length < 2) return;

    const coordinates = pointsRef.current.map((p) => [p.lng, p.lat]);
    // Close the polygon if we have 3+ points
    if (pointsRef.current.length >= 3) {
      coordinates.push(coordinates[0]);
    }

    const geojson: GeoJSON.Feature<GeoJSON.Polygon | GeoJSON.LineString> = {
      type: "Feature",
      properties: {},
      geometry:
        pointsRef.current.length >= 3
          ? { type: "Polygon", coordinates: [coordinates] }
          : { type: "LineString", coordinates },
    };

    const source = mapInstance.getSource(sourceId);
    if (source && "setData" in source) {
      source.setData(geojson as any);
    }
  }, [mapInstance]);

  const handleMapClick = useCallback(
    (e: maplibregl.MapMouseEvent) => {
      if (!isDrawingMode) return;
      pointsRef.current.push(e.lngLat);
      updatePolygonOnMap();
    },
    [isDrawingMode, updatePolygonOnMap]
  );

  const handleComplete = useCallback(() => {
    if (pointsRef.current.length < 3) return;

    const coordinates = pointsRef.current.map((p) => [p.lng, p.lat]);
    coordinates.push(coordinates[0]); // Close polygon

    const polygon: GeoJSON.Feature<GeoJSON.Polygon> = {
      type: "Feature",
      properties: {},
      geometry: {
        type: "Polygon",
        coordinates: [coordinates],
      },
    };

    setDrawnPolygon(polygon);
    setIsDrawingMode(false);
    onComplete(polygon);
  }, [onComplete, setDrawnPolygon, setIsDrawingMode]);

  const handleCancel = useCallback(() => {
    pointsRef.current = [];
    setIsDrawingMode(false);
    setDrawnPolygon(null);

    // Remove drawing layers
    if (mapInstance) {
      if (mapInstance.getLayer("drawing-polygon-fill")) {
        mapInstance.removeLayer("drawing-polygon-fill");
      }
      if (mapInstance.getLayer("drawing-polygon-line")) {
        mapInstance.removeLayer("drawing-polygon-line");
      }
      if (mapInstance.getSource(sourceId)) {
        mapInstance.removeSource(sourceId);
      }
    }

    onCancel();
  }, [mapInstance, onCancel, setIsDrawingMode, setDrawnPolygon]);

  useEffect(() => {
    if (!mapInstance || !isDrawingMode) return;

    // Add source for drawing
    if (!mapInstance.getSource(sourceId)) {
      mapInstance.addSource(sourceId, {
        type: "geojson",
        data: { type: "FeatureCollection", features: [] },
      });

      mapInstance.addLayer({
        id: "drawing-polygon-fill",
        type: "fill",
        source: sourceId,
        paint: {
          "fill-color": "#3b82f6",
          "fill-opacity": 0.3,
        },
      });

      mapInstance.addLayer({
        id: "drawing-polygon-line",
        type: "line",
        source: sourceId,
        paint: {
          "line-color": "#3b82f6",
          "line-width": 2,
          "line-dasharray": [2, 2],
        },
      });
    }

    mapInstance.on("click", handleMapClick);
    mapInstance.getCanvas().style.cursor = "crosshair";

    return () => {
      mapInstance.off("click", handleMapClick);
      mapInstance.getCanvas().style.cursor = "";
    };
  }, [mapInstance, isDrawingMode, handleMapClick]);

  if (!isDrawingMode) return null;

  return (
    <Paper
      className="fixed top-4 left-1/2 -translate-x-1/2 z-20"
      shadow="md"
      p="md"
      withBorder
    >
      <Text size="sm" mb="sm">
        Click on the map to draw your nation's boundary. Minimum 3 points required.
      </Text>
      <Group justify="center">
        <Button
          size="sm"
          leftSection={<IconCheck size={16} />}
          onClick={handleComplete}
          disabled={pointsRef.current.length < 3}
        >
          Complete
        </Button>
        <Button
          size="sm"
          variant="light"
          color="red"
          leftSection={<IconX size={16} />}
          onClick={handleCancel}
        >
          Cancel
        </Button>
      </Group>
    </Paper>
  );
}
```

**Step 4: Create main page**

```typescript
// src/app/page.tsx
"use client";

import { useState, useCallback } from "react";
import { WorldMap } from "@/components/map/world-map";
import { NationModal } from "@/components/nation/nation-modal";
import { NationSelectionPopup } from "@/components/map/nation-selection-popup";
import { NationSubmitForm } from "@/components/nation/nation-submit-form";
import { MainPageControls } from "@/components/controls/main-page-controls";
import { AddNationButton } from "@/components/controls/add-nation-button";
import { PolygonDraw } from "@/components/map/polygon-draw";
import { useMapStore } from "@/stores/map-store";
import { LngLat } from "maplibre-gl";

interface NationAtPoint {
  id: string;
  name: string;
  slug: string;
  flagUrl: string | null;
}

export default function HomePage() {
  const [selectedNationSlug, setSelectedNationSlug] = useState<string | null>(null);
  const [submitFormOpen, setSubmitFormOpen] = useState(false);
  const [overlappingNations, setOverlappingNations] = useState<NationAtPoint[] | null>(null);
  const [popupPosition, setPopupPosition] = useState<{ x: number; y: number } | null>(null);
  const [drawnBoundary, setDrawnBoundary] = useState<GeoJSON.Feature<GeoJSON.Polygon> | null>(null);

  const { setIsDrawingMode, isDrawingMode } = useMapStore();

  const handleNationClick = useCallback((slug: string) => {
    setSelectedNationSlug(slug);
    setOverlappingNations(null);
    setPopupPosition(null);
  }, []);

  const handleMultipleNations = useCallback((nations: NationAtPoint[], lngLat: LngLat) => {
    setOverlappingNations(nations);
    setPopupPosition({
      x: window.innerWidth / 2,
      y: window.innerHeight / 2,
    });
  }, []);

  const handleClosePopup = useCallback(() => {
    setOverlappingNations(null);
    setPopupPosition(null);
  }, []);

  const handleStartDrawing = useCallback(() => {
    setIsDrawingMode(true);
  }, [setIsDrawingMode]);

  const handlePolygonComplete = useCallback((polygon: GeoJSON.Feature<GeoJSON.Polygon>) => {
    setDrawnBoundary(polygon);
    setSubmitFormOpen(true);
  }, []);

  const handlePolygonCancel = useCallback(() => {
    setDrawnBoundary(null);
  }, []);

  const handleSubmitFormClose = useCallback(() => {
    setSubmitFormOpen(false);
    setDrawnBoundary(null);
  }, []);

  return (
    <div className="h-screen w-screen overflow-hidden relative">
      {/* Full-screen globe map */}
      <WorldMap
        onNationClick={handleNationClick}
        onMultipleNationsAtPoint={handleMultipleNations}
      />

      {/* Right-side controls */}
      <MainPageControls />

      {/* Bottom center "+" button to add nation */}
      {!isDrawingMode && (
        <AddNationButton onStartDrawing={handleStartDrawing} />
      )}

      {/* Polygon drawing mode UI */}
      <PolygonDraw
        onComplete={handlePolygonComplete}
        onCancel={handlePolygonCancel}
      />

      {/* Overlapping nations selection popup */}
      {overlappingNations && popupPosition && (
        <NationSelectionPopup
          nations={overlappingNations}
          position={popupPosition}
          onSelect={handleNationClick}
          onClose={handleClosePopup}
        />
      )}

      {/* Nation details modal */}
      <NationModal
        slug={selectedNationSlug}
        onClose={() => setSelectedNationSlug(null)}
      />

      {/* Nation submission form with pre-filled boundary */}
      <NationSubmitForm
        opened={submitFormOpen}
        onClose={handleSubmitFormClose}
        initialBoundary={drawnBoundary}
      />
    </div>
  );
}
```

**Step 5: Update NationSubmitForm to accept initial boundary**

Update `src/components/nation/nation-submit-form.tsx` to include an `initialBoundary` prop that pre-fills the GeoJSON field:

```typescript
interface NationSubmitFormProps {
  opened: boolean;
  onClose: () => void;
  initialBoundary?: GeoJSON.Feature<GeoJSON.Polygon> | null;
}

export function NationSubmitForm({ opened, onClose, initialBoundary }: NationSubmitFormProps) {
  // ... existing code ...

  const form = useForm({
    initialValues: {
      name: "",
      description: "",
      boundaryGeoJson: initialBoundary ? JSON.stringify(initialBoundary) : "",
    },
    // ... validation ...
  });

  // Reset form when initialBoundary changes
  useEffect(() => {
    if (initialBoundary) {
      form.setFieldValue("boundaryGeoJson", JSON.stringify(initialBoundary));
    }
  }, [initialBoundary]);

  // ... rest of component ...
}
```

**Step 6: Commit**

```bash
git add .
git commit -m "feat: add main page with globe map, right-side controls, and polygon drawing for nation creation"
```

---

## Phase 5: Admin Panel

### Task 21: Create Admin Layout and Page

**Files:**

- Create: `src/app/admin/layout.tsx`
- Create: `src/app/admin/page.tsx`
- Create: `src/components/admin/pending-nations-table.tsx`
- Create: `src/components/admin/nation-review-modal.tsx`

**Step 1: Create admin layout with auth protection**

```typescript
// src/app/admin/layout.tsx
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { redirect } from "next/navigation";
import { Container, Title, Text, Paper } from "@mantine/core";

export default async function AdminLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const session = await getServerSession(authOptions);

  if (!session?.user) {
    redirect("/api/auth/signin");
  }

  if (!session.user.isAdmin) {
    return (
      <Container size="sm" className="py-20">
        <Paper p="xl" withBorder>
          <Title order={2} c="red" mb="md">
            Access Denied
          </Title>
          <Text c="dimmed">
            You do not have permission to access the admin panel.
          </Text>
        </Paper>
      </Container>
    );
  }

  return (
    <div className="min-h-screen bg-gray-50">
      <header className="bg-white border-b">
        <Container size="xl" className="py-4">
          <Title order={2}>Admin Panel</Title>
        </Container>
      </header>
      <Container size="xl" className="py-8">
        {children}
      </Container>
    </div>
  );
}
```

**Step 2: Create pending nations table**

```typescript
// src/components/admin/pending-nations-table.tsx
"use client";

import { useEffect, useState } from "react";
import {
  Table,
  Badge,
  Button,
  Group,
  Text,
  Skeleton,
  Alert,
} from "@mantine/core";
import { IconEye, IconCheck, IconX } from "@tabler/icons-react";

interface Nation {
  id: string;
  name: string;
  slug: string;
  state: string;
  description: string | null;
  createdAt: string;
  submittedBy: {
    email: string;
    firstName: string;
    lastName: string;
  } | null;
}

interface PendingNationsTableProps {
  onReview: (id: string) => void;
  onApprove: (id: string) => void;
  onReject: (id: string) => void;
}

export function PendingNationsTable({
  onReview,
  onApprove,
  onReject,
}: PendingNationsTableProps) {
  const [nations, setNations] = useState<Nation[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchNations = async () => {
    try {
      const response = await fetch("/api/admin/nations?state=pending");
      if (!response.ok) throw new Error("Failed to fetch");
      const data = await response.json();
      setNations(data.nations);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to load nations");
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchNations();
  }, []);

  if (loading) {
    return (
      <div className="space-y-2">
        {[1, 2, 3].map((i) => (
          <Skeleton key={i} height={50} />
        ))}
      </div>
    );
  }

  if (error) {
    return (
      <Alert color="red" title="Error">
        {error}
      </Alert>
    );
  }

  if (nations.length === 0) {
    return (
      <Text c="dimmed" ta="center" py="xl">
        No pending nations to review.
      </Text>
    );
  }

  return (
    <Table striped highlightOnHover>
      <Table.Thead>
        <Table.Tr>
          <Table.Th>Name</Table.Th>
          <Table.Th>Submitted By</Table.Th>
          <Table.Th>Date</Table.Th>
          <Table.Th>Actions</Table.Th>
        </Table.Tr>
      </Table.Thead>
      <Table.Tbody>
        {nations.map((nation) => (
          <Table.Tr key={nation.id}>
            <Table.Td>
              <Text fw={500}>{nation.name}</Text>
            </Table.Td>
            <Table.Td>
              {nation.submittedBy ? (
                <Text size="sm">
                  {nation.submittedBy.firstName} {nation.submittedBy.lastName}
                </Text>
              ) : (
                <Text size="sm" c="dimmed">Anonymous</Text>
              )}
            </Table.Td>
            <Table.Td>
              <Text size="sm" c="dimmed">
                {new Date(nation.createdAt).toLocaleDateString()}
              </Text>
            </Table.Td>
            <Table.Td>
              <Group gap="xs">
                <Button
                  size="xs"
                  variant="light"
                  leftSection={<IconEye size={14} />}
                  onClick={() => onReview(nation.id)}
                >
                  Review
                </Button>
                <Button
                  size="xs"
                  color="green"
                  variant="light"
                  leftSection={<IconCheck size={14} />}
                  onClick={() => onApprove(nation.id)}
                >
                  Approve
                </Button>
                <Button
                  size="xs"
                  color="red"
                  variant="light"
                  leftSection={<IconX size={14} />}
                  onClick={() => onReject(nation.id)}
                >
                  Reject
                </Button>
              </Group>
            </Table.Td>
          </Table.Tr>
        ))}
      </Table.Tbody>
    </Table>
  );
}
```

**Step 3: Create nation review modal**

```typescript
// src/components/admin/nation-review-modal.tsx
"use client";

import { useEffect, useState } from "react";
import {
  Modal,
  Text,
  Badge,
  Button,
  Group,
  Stack,
  Skeleton,
  Alert,
  Divider,
} from "@mantine/core";
import { IconCheck, IconX } from "@tabler/icons-react";

interface NationReviewModalProps {
  nationId: string | null;
  onClose: () => void;
  onApprove: (id: string) => void;
  onReject: (id: string) => void;
}

export function NationReviewModal({
  nationId,
  onClose,
  onApprove,
  onReject,
}: NationReviewModalProps) {
  const [nation, setNation] = useState<any>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (!nationId) return;

    setLoading(true);
    setError(null);

    fetch(`/api/admin/nations/${nationId}`)
      .then((res) => {
        if (!res.ok) throw new Error("Failed to fetch nation");
        return res.json();
      })
      .then((data) => setNation(data))
      .catch((err) => setError(err.message))
      .finally(() => setLoading(false));
  }, [nationId]);

  return (
    <Modal
      opened={!!nationId}
      onClose={onClose}
      title="Review Nation Submission"
      size="lg"
    >
      {loading && (
        <Stack gap="md">
          <Skeleton height={30} />
          <Skeleton height={100} />
          <Skeleton height={50} />
        </Stack>
      )}

      {error && (
        <Alert color="red" title="Error">
          {error}
        </Alert>
      )}

      {nation && !loading && (
        <Stack gap="md">
          <div>
            <Text size="xl" fw={700}>{nation.name}</Text>
            <Group gap="xs" mt="xs">
              <Badge color={nation.state === "pending" ? "yellow" : "green"}>
                {nation.state}
              </Badge>
            </Group>
          </div>

          {nation.description && (
            <div>
              <Text size="sm" fw={500} mb="xs">Description</Text>
              <Text size="sm" c="dimmed">{nation.description}</Text>
            </div>
          )}



          {nation.boundaryGeoJson && (
            <div>
              <Text size="sm" fw={500} mb="xs">Has Boundary Data</Text>
              <Badge color="blue">GeoJSON provided</Badge>
            </div>
          )}

          {nation.submittedBy && (
            <div>
              <Text size="sm" fw={500}>Submitted By</Text>
              <Text size="sm" c="dimmed">
                {nation.submittedBy.firstName} {nation.submittedBy.lastName} ({nation.submittedBy.email})
              </Text>
            </div>
          )}

          <Divider />

          <Group justify="flex-end">
            <Button
              color="red"
              variant="light"
              leftSection={<IconX size={16} />}
              onClick={() => {
                onReject(nation.id);
                onClose();
              }}
            >
              Reject
            </Button>
            <Button
              color="green"
              leftSection={<IconCheck size={16} />}
              onClick={() => {
                onApprove(nation.id);
                onClose();
              }}
            >
              Approve
            </Button>
          </Group>
        </Stack>
      )}
    </Modal>
  );
}
```

**Step 4: Create admin page**

```typescript
// src/app/admin/page.tsx
"use client";

import { useState, useCallback } from "react";
import { Paper, Title, Tabs } from "@mantine/core";
import { notifications } from "@mantine/notifications";
import { IconClock, IconCheck } from "@tabler/icons-react";
import { PendingNationsTable } from "@/components/admin/pending-nations-table";
import { NationReviewModal } from "@/components/admin/nation-review-modal";

export default function AdminPage() {
  const [reviewNationId, setReviewNationId] = useState<string | null>(null);
  const [refreshKey, setRefreshKey] = useState(0);

  const handleApprove = useCallback(async (id: string) => {
    try {
      const response = await fetch(`/api/admin/nations/${id}`, {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ state: "approved" }),
      });

      if (!response.ok) throw new Error("Failed to approve");

      notifications.show({
        title: "Nation Approved",
        message: "The nation is now visible on the public map.",
        color: "green",
      });

      setRefreshKey((k) => k + 1);
    } catch (error) {
      notifications.show({
        title: "Error",
        message: "Failed to approve nation",
        color: "red",
      });
    }
  }, []);

  const handleReject = useCallback(async (id: string) => {
    try {
      const response = await fetch(`/api/admin/nations/${id}`, {
        method: "DELETE",
      });

      if (!response.ok) throw new Error("Failed to reject");

      notifications.show({
        title: "Nation Rejected",
        message: "The submission has been removed.",
        color: "orange",
      });

      setRefreshKey((k) => k + 1);
    } catch (error) {
      notifications.show({
        title: "Error",
        message: "Failed to reject nation",
        color: "red",
      });
    }
  }, []);

  return (
    <div className="space-y-6">
      <Title order={3}>Nation Moderation</Title>

      <Paper withBorder p="md">
        <Tabs defaultValue="pending">
          <Tabs.List>
            <Tabs.Tab value="pending" leftSection={<IconClock size={16} />}>
              Pending Review
            </Tabs.Tab>
            <Tabs.Tab value="approved" leftSection={<IconCheck size={16} />}>
              Approved
            </Tabs.Tab>
          </Tabs.List>

          <div className="mt-4">
            <Tabs.Panel value="pending">
              <PendingNationsTable
                key={refreshKey}
                onReview={setReviewNationId}
                onApprove={handleApprove}
                onReject={handleReject}
              />
            </Tabs.Panel>

            <Tabs.Panel value="approved">
              {/* Could add approved nations table here */}
              <div className="py-8 text-center text-gray-500">
                Approved nations management coming soon.
              </div>
            </Tabs.Panel>
          </div>
        </Tabs>
      </Paper>

      <NationReviewModal
        nationId={reviewNationId}
        onClose={() => setReviewNationId(null)}
        onApprove={handleApprove}
        onReject={handleReject}
      />
    </div>
  );
}
```

**Step 5: Commit**

```bash
git add .
git commit -m "feat: add admin panel with nation moderation"
```

---

## Phase 6: Final Integration & Testing

### Task 22: Final Testing Checklist

**Manual Testing Steps:**

1. **Public Map Access**
   - [ ] Visit homepage without authentication
   - [ ] Verify only approved nations appear on map
   - [ ] Click a nation boundary → details modal opens
   - [ ] Test all modal tabs (Languages with Phrases, Content with categories)

2. **Overlapping Regions**
   - [ ] If boundaries overlap, clicking shows selection popup
   - [ ] Selecting a nation from popup opens its modal

3. **Nation Submission**
   - [ ] Click "Submit Nation" button
   - [ ] Fill form and submit
   - [ ] Verify nation created with "pending" state
   - [ ] Verify it does NOT appear on public map

4. **Google Authentication**
   - [ ] Click "Sign in with Google"
   - [ ] Complete OAuth flow
   - [ ] Verify user session created

5. **Admin Panel**
   - [ ] Log in as admin user
   - [ ] Navigate to /admin
   - [ ] View pending nations
   - [ ] Review nation details
   - [ ] Approve a nation → verify it appears on map
   - [ ] Reject a nation → verify it's removed

**Step 1: Run all checks**

```bash
npm run build
npm run start
```

**Step 2: Final commit**

```bash
git add .
git commit -m "feat: complete cultures.com implementation with moderation"
```

---

## Summary

This plan implements a complete cultures exploration platform with:

- **Mantine + TailwindCSS** for UI (no other UI libraries)
- **Nation `state` field** with "approved" and "pending" values
- **Public map showing only approved nations**
- **Google OAuth** authentication via Passport.js/NextAuth
- **Open nation submission** for anyone (registered or not)
- **Admin moderation panel** at `/admin` for approving/rejecting submissions
- **Nation details modal** on map boundary click
- **Overlapping region handling** with selection popup
- **PostGIS `GEOMETRY(MultiPolygon, 4326)`** for spatial queries
